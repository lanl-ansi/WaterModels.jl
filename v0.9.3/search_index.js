var documenterSearchIndex = {"docs":
[{"location":"math-model.html#Mathematical-Models-in-WaterModels","page":"Mathematical Models","title":"Mathematical Models in WaterModels","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Much of the following text is adapted or directly copied from [1] and [2], which were historically developed alongside WaterModels. If you have found WaterModels useful in your research, please consider referencing these works in your manuscripts.","category":"page"},{"location":"math-model.html#Notation-for-Sets","page":"Mathematical Models","title":"Notation for Sets","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"A water distribution network (WDN) is represented by a directed graph mathcalG = (mathcalN mathcalL), where mathcalN is the set of nodes and mathcalL is the set of arcs (conventionally \"links,\" e.g., pipes and valves). Temporal evolution of the network is represented by a set tildemathcalK, denoting the set of all time indices considered. In summary, the following sets are commonly used when defining a WaterModels problem formulation:","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Notation WaterModels Translation Description\ntildemathcalK nw_ids(wm) time indices (multinetwork indices labeled by n)\nmathcalK nw_ids[1:end-1] time indices without last index\nmathcalN wm.ref[:nw][n][:node] nodes (to which nodal-type components are attached)\nmathcalD wm.ref[:nw][n][:demand] demands\nmathcalR wm.ref[:nw][n][:reservoir] reservoirs\nmathcalT wm.ref[:nw][n][:tank] tanks\nmathcalA subset mathcalL wm.ref[:nw][n][:pipe] pipes\nmathcalA^textrmdes subset mathcalL wm.ref[:nw][n][:des_pipe_arc] design pipe arcs\nmathcalP subset mathcalL wm.ref[:nw][n][:pump] pumps\nmathcalW subset mathcalL wm.ref[:nw][n][:regulator] regulators\nmathcalS subset mathcalL wm.ref[:nw][n][:short_pipe] short pipes\nmathcalV subset mathcalL wm.ref[:nw][n][:valve] valves","category":"page"},{"location":"math-model.html#Physical-Feasibility","page":"Mathematical Models","title":"Physical Feasibility","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Below, we describe the foundational steady-state physical model used by all WaterModels problem specifications.","category":"page"},{"location":"math-model.html#Nodes","page":"Mathematical Models","title":"Nodes","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Nodal potentials are denoted by the variables h_i^k, i in mathcalN, k in tildemathcalK, where each h_i^k represents the total hydraulic head in units of length. This quantity (hereafter referred to as \"head\") assimilates elevation and pressure heads. Each head is constrained between lower and upper bounds, underlineh_i^k and overlineh_i^k, respectively. This implies the head constraints","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    underlineh_i^k leq h_i^k leq overlineh_i^k  forall i in mathcalN  forall k in tildemathcalK labelequationnode-head-bounds\nendequation*","category":"page"},{"location":"math-model.html#Demands","page":"Mathematical Models","title":"Demands","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Demands are nodes where water is supplied to end consumers. Each demand is associated with a constant, overlineq^k_i, that denotes the demanded volumetric flow rate, where a positive value indicates consumption. Without loss of generality, we also allow negative flows to represent injections (e.g., from a well). When a demand is \"dispatchable,\" the variables q_i^k in mathbbR, i in mathcalD, k in mathcalK, denote the flow consumed or supplied by each demand node. When a demand is constant, q_i^k = overlineq^k_i.","category":"page"},{"location":"math-model.html#Reservoirs","page":"Mathematical Models","title":"Reservoirs","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Reservoirs are nodes where water is supplied to the WDN. Each reservoir is modeled as an infinite source of flow with zero pressure head and constant elevation over a time step (i.e., underlineh_i^k = overlineh_i^k at every reservoir, i in mathcalR). Furthermore, the variables q_i^k geq 0, i in mathcalR, k in mathcalK, are used to denote the outflow of water from a reservoir i at time index k in mathcalK.","category":"page"},{"location":"math-model.html#Tanks","page":"Mathematical Models","title":"Tanks","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Tanks store and discharge water over time. Here, all tanks are assumed to be cylindrical with a fixed diameter D_i, i in mathcalT. We assume there is no pressure head in the tanks, i.e., they are vented to the atmosphere. The bottom of each tank, B_i, is located at or below the minimum water elevation, i.e., B_i leq underlineh_i^k, i in mathcalT, and the maximum elevation of water is assumed to be overlineh_i^k. The bounded variables q_i^k, i in mathcalT, k in mathcalK, denote the outflow (positive) or inflow (negative) through each tank. The water volumes within the tanks are","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    v_i^k = fracpi4 D_i^2 (h_i^k - B_i^k)  forall i in mathcalT  forall k in tildemathcalK labelequationtank-volume-expression\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"The Euler steps for integrating all tank volumes across time indices are then imposed with","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    v_i^k+1 = v_i^k - Delta t^k q_i^k  forall i in mathcalT  forall k in mathcalK labelequationtank-volume-integration\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"where Delta t^k is the length of the time interval that connects times k in mathcalK and k + 1 in tildemathcalK.","category":"page"},{"location":"math-model.html#Links","page":"Mathematical Models","title":"Links","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Every link component (i j) in mathcalL is associated with a variable, q_ij^k, which denotes the volumetric flow rate across that component. Assuming lower and upper bounds of underlineq_ij^k and overlineq_ij^k, respectively, these variables are bounded via","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    underlineq_ij^k leq q_ij^k leq overlineq_ij^k  forall (i j) in mathcalL  forall k in mathcalK labelequationmincp-flow-bounds\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"When q_ij^k is positive, flow on (i j) is transported from node i to j. When q_ij^k is negative, flow is transported from node j to i. At zero flow, the flow direction is considered ambiguous.","category":"page"},{"location":"math-model.html#Pipes","page":"Mathematical Models","title":"Pipes","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Pipes are the primary means for transporting water in a WDN. Water flowing through a pipe will exhibit frictional energy loss due to contact with the pipe wall. In WaterModels, energy loss relationships that link pipe flow and head (i.e., \"head loss\" equations) are modeled by the Darcy-Weisbach or Hazen-Williams equations [3], requiring the constraints","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    h_i^k - h_j^k = L_ij r_ij q_ij^k leftlvert q_ij^k rightrvert^alpha - 1  forall (i j) in mathcalA  forall k in mathcalK labelequationmincp-pipe-head-loss\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Here, alpha = 20 for the Darcy-Weisbach relationship, alpha = 1852 for the Hazen-Williams relationship, and r_ij denotes the resistance per unit length, which comprises all length-independent constants that appear in both equations. Further, note that we make an assumption of constant resistance for the Darcy-Weisbach relationship. This is typically described as a nonlinear function of flow rate.","category":"page"},{"location":"math-model.html#Design-Pipes","page":"Mathematical Models","title":"Design Pipes","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"In problem specifications involving network design, design pipes are considered pipes that are eligible for construction within an existing WDN. For each design pipe, a binary variable z_ijr^k is used to denote whether or not a design pipe with resistance r is constructed between nodes i and j. Similarly, the flow transported through a design pipe is denoted by q_ijr^k. Note that in both variable notations, r is a required index since multiple potential design pipes may appear along arc (i j). When a design pipe is not constructed, it follows that flow cannot be transported through the design pipe, which is modeled via the constraints","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    underlineq_ijr^k z_ijr^k leq q_ijr^k leq overlineq_ijr^k z_ijr^k  z_ijr^k in 0 1  forall (i j) in mathcalA^textrmdes  forall r in mathcalA^textrmdes_ij  forall k in mathcalK labelequationmincp-des-pipe-flow-bounds\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Here, mathcalA^textrmdes_ij is the set of design resistances available for constructing a pipe along arc (i j). These constraints imply that, when z_ijr^k is zero, zero flow can be transported through the pipe.","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Similar to the above, for each possible design pipe, a head difference variable Delta h_ijr^k is introduced to model the resulting head difference from a design pipe with resistance r along arc (i j). If the design pipe is not constructed, the head difference variable associated with it is assumed to be zero. This is modeled via the constraints","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginaligned\nDelta h_ijr^k geq (underlineh_i^k - overlineh_j^k) z_ijr^k  forall (i j) in mathcalA^textrmdes  forall r in mathcalA^textrmdes_ij  forall k in mathcalK \nDelta h_ijr^k leq (overlineh_i^k - underlineh_j^k) z_ijr^k  forall (i j) in mathcalA^textrmdes  forall r in mathcalA^textrmdes_ij  forall k in mathcalK\nendaligned","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"As with pipes, the head loss along each design pipe is then modeled via","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    Delta h_ijr^k = L_ijr r q_ijr^k leftlvert q_ijr^k rightrvert^alpha - 1  forall (i j) in mathcalA^textrmdes  forall r in mathcalA^textrmdes_ij  forall k in mathcalK labelequationmincp-des-pipe-head-loss\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Since only one design pipe can be selected per arc, the following constraints are applied:","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    sum_r in mathcalA^textrmdes_ij z_ijr^k = 1  forall (i j) in mathcalA^textrmdes  forall k in mathcalK\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Since only one design pipe will be constructed, the actual head loss experienced between nodes i and j is modeled with respect to individual design pipe head differences via","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    sum_r in mathcalA^textrmdes_ij Delta h_ijr^k = h_i - h_j  forall (i j) in mathcalA^textrmdes  forall k in mathcalK\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Finally, similar to the head difference sum above, the sum of flows from all design pipes must be equal to the flow transported between nodes i and j, i.e.,","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    sum_r in mathcalA^textrmdes_ij q_ijr^k = q_ij^k  forall (i j) in mathcalA^textrmdes  forall k in mathcalK\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"We remark that this constraint is not modeled directly by WaterModels but is provided for simplifying the flow conservation relationship described later in this document. In actuality, each term along (i j) where a design pipe appears in the flow conservation constraint is replaced with the left-hand side of each above constraint.","category":"page"},{"location":"math-model.html#Pumps","page":"Mathematical Models","title":"Pumps","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Each pump (i j) in mathcalP increases the head from node i to j when active and permits only unidirectional flow. In WaterModels, we consider only fixed-speed pumps. When the pump is off, there is zero flow, and heads at adjacent nodes are decoupled. When the pump is on, there is positive flow (greater than or equal to some fixed underlineq_ij^k +), and the head increase from i to j is modeled by a nonlinear function. The variable z_ij^k in 0 1 indicates the status of each pump, where z_ij^k = 1 if q_ij^k geq underlineq_ij^k + and z_ij^k = 0 if q_ij^k  underlineq_ij^k +. This implies the disjunctive bounds","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    underlineq_ij^k = 0 leq underlineq_ij^k + z_ij^k leq q_ij^k leq overlineq_ij^k z_ij^k  z_ij^k in 0 1  forall (i j) in mathcalP  forall k in mathcalK labelequationmincp-pump-flow-bounds\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"The variable g_ij^k geq 0 is introduced for each pump to denote the head increase (or gain) that results from that pump.  Various methods for modeling head gain relationships are provided by WaterModels, but we forgo their description, here. We do remark that the relationship between head gain and flow is typically nonlinear in its most accurate form. To ensure the decoupling of hydraulic heads when a pump is off, the following disjunctive constraints are employed:","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginaligned\n    h_i^k - h_j^k + g_ij^k leq (1 - z_ij^k) (overlineh_i^k - underlineh_j^k)  forall (i j) in mathcalP  forall k in mathcalK \n    h_i^k - h_j^k + g_ij^k geq (1 - z_ij^k) (underlineh_i^k - overlineh_j^k)  forall (i j) in mathcalP  forall k in mathcalK\nendaligned","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Note that when z_ij^k = 1, the pump is on, and the head gain between the two nodes is g_ij^k.","category":"page"},{"location":"math-model.html#Regulators","page":"Mathematical Models","title":"Regulators","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Large pipes are usually operated at higher pressures than other portions of the WDN. As such, interconnection of large pipes with smaller pipes often requires the use of pressure regulators (i.e., pressure-reducing control valves) to reduce pressure between differently-sized pipes. The operating status of a regulator is modeled using a binary variable z_ij in 0 1, where z_ij = 1 and z_ij = 0 indicate active and inactive statuses, respectively. These binary variables restrict the flow across each regulator as","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    underlineq_ij^k z_ij^k leq q_ij^k leq overlineq_ij^k z_ij^k  z_ij^k in 0 1  forall (i j) in mathcalW  forall k in mathcalK labelequationmincp-regulator-flow-bounds\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"When the regulator (i j) in mathcalW is operational (active), it will ensure head at the downstream node j in mathcalN is equal to a predefined setpoint, xi_j^k. It will also ensure that head loss from i to j is nonnegative. When the regulator is inactive, heads at connecting nodes are decoupled, although head loss is nonpositive. These disjunctive phenomena are modeled via the following set of constraints involving the binary indicator variables z_ij^k:","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginaligned\nh_j^k geq underlineh_j^k (1 - z_ij^k) + xi_j^k z_ij^k  forall (i j) in mathcalW  forall k in mathcalK \nh_j^k leq overlineh_j^k (1 - z_ij^k) + xi_j^k z_ij^k  forall (i j) in mathcalW  forall k in mathcalK \nh_i^k - h_j^k geq (underlineh_i^k - overlineh_j^k) (1 - z_ij^k)  forall (i j) in mathcalW  forall k in mathcalK \nh_i^k - h_j^k leq (overlineh_i^k - underlineh_j^k) z_ij^k  forall (i j) in mathcalW  forall k in mathcalK\nendaligned","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"That is, if z_ij^k = 1, then h_j^k = xi_j^k, and the head loss between i and j is nonnegative. Otherwise, if z_ij^k = 0, then h_i^k and h_j^k are decoupled, and the head loss is nonpositive.","category":"page"},{"location":"math-model.html#Short-Pipes","page":"Mathematical Models","title":"Short Pipes","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Short pipes are treated as pipes with negligible length, i.e., there is no head loss across a short pipe. They are modeled via the constraints","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    h_i^k - h_j^k = 0  forall (i j) in mathcalS  forall k in mathcalK labelequationmincp-short-pipe-head-loss\nendequation*","category":"page"},{"location":"math-model.html#Valves","page":"Mathematical Models","title":"Valves","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Valves control the flow of water to specific portions of the WDN. Here, valves are elements that are either open or closed. The operating status of each valve (i j) in mathcalV is indicated using a binary variable, z_ij^k in 0 1, where z_ij^k = 1 corresponds to an open valve and z_ij^k = 0 to a closed valve. These binary variables restrict the flow across each valve as","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    underlineq_ij^k z_ij^k leq q_ij^k leq overlineq_ij^k z_ij^k  z_ij^k in 0 1  forall (i j) in mathcalV  forall k in mathcalK labelequationmincp-valve-flow-bounds\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Furthermore, when a valve is open, the heads at the nodes connected by that valve are equal. When the valve is closed, these heads are decoupled. This disjunctive phenomenon is modeled via the following set of constraints involving the binary indicator variables z_ij^k:","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"beginequation*\n    (1 - z_ij^k) (underlineh_i^k - overlineh_j^k) leq h_i^k - h_j^k leq (1 - z_ij^k) (overlineh_i^k - underlineh_j^k)  forall (i j) in mathcalV  forall k inmathcalK labelequationmincp-valve-head\nendequation*","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"That is, if z_ij^k = 1, then h_i^k = h_j^k. Otherwise, if z_ij^k = 0, then h_i^k and h_j^k are decoupled.","category":"page"},{"location":"math-model.html#Conservation-of-Flow","page":"Mathematical Models","title":"Conservation of Flow","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"Finally, mass conservation of the system is ensured by equating volumetric flow rate production to demand. This is accomplished via the constraints","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"sum_(j i) in delta_i^- q_ji^k - sum_(i j) in delta_i^+ q_ij^k = sum_ell in mathcalD_i q_ell^k - sum_ell in mathcalR_i q_ell^k - sum_ell in mathcalT_i q_ell^k  forall i in mathcalN  forall k in mathcalK","category":"page"},{"location":"math-model.html#Remarks","page":"Mathematical Models","title":"Remarks","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"The different Network Formulations implemented by WaterModels aim at approximating or relaxing nonconvex nonlinearities that model complex physical phenomena in the above system of constraints. More specifically, they often aim at approximating or relaxing pipe head loss and pump head gain relationships, which are two of the primary sources of nonlinearity. Here, we forgo complete mathematical descriptions of these approximations and relaxations. If more details are required, please refer to the references described below, the functions used to implement the constraints for a specific formulation, or contact the WaterModels maintainers.","category":"page"},{"location":"math-model.html#References","page":"Mathematical Models","title":"References","text":"","category":"section"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"[1] Tasseff, B., Bent, R., Epelman, M. A., Pasqualini, D., & Van Hentenryck, P. (2020). Exact mixed-integer convex programming formulation for optimal water network design. arXiv preprint arXiv:2010.03422.","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"[2] Tasseff, B., Bent, R., Coffrin, C., Barrows, C., Sigler, D., Stickel, J., Zamzam, S., Liu, Y. & Van Hentenryck, P. (2022). Polyhedral relaxations for optimal pump scheduling of potable water distribution networks. arXiv preprint arXiv:2208.03551.","category":"page"},{"location":"math-model.html","page":"Mathematical Models","title":"Mathematical Models","text":"[3] Ormsbee, L., & Walski, T. (2016). Darcy-Weisbach versus Hazen-Williams: No calm in West Palm. In World Environmental and Water Resources Congress 2016 (pp. 455-464).","category":"page"},{"location":"network-data.html#WaterModels-Network-Data-Format","page":"Network Data Format","title":"WaterModels Network Data Format","text":"","category":"section"},{"location":"network-data.html#The-Network-Data-Dictionary","page":"Network Data Format","title":"The Network Data Dictionary","text":"","category":"section"},{"location":"network-data.html","page":"Network Data Format","title":"Network Data Format","text":"Internally, WaterModels uses a dictionary to store network data. The dictionary uses strings as key values so it can be serialized to JSON for algorithmic data exchange. When used, the data is assumed to be in per-unit (non-dimenisionalized) or SI units. The network data dictionary structure is organized as follows:","category":"page"},{"location":"network-data.html","page":"Network Data Format","title":"Network Data Format","text":"{\n    \"name\": <string>,       # Name for the network model.\n    \"multinetwork\": <bool>  # Whether or not the network data describes a multinetwork (e.g., a time series of networks).\n    \"per_unit\": <bool>,     # Whether the data is in per-unit (non-dimensionalized) or SI units.\n    \"base_flow\": <float>,   # Base for non-dimensionalizing volumetric flow rate. SI units are cubic meters per second.\n    \"base_head\": <float>,   # Base for non-dimensionalizing total hydraulic head head. SI units are meters.\n    \"base_length\": <float>, # Base for non-dimensionalizing length. SI units are meters.\n    \"base_mass\": <float>,   # Base for non-dimensionalizing mass. SI units are kilograms.\n    \"base_time\": <float>,   # Base for non-dimensionalizing time. SI units are seconds.\n    \"head_loss\": <string>,  # Pipe head loss form. Can be \"H-W\" for Hazen-Williams or \"D-W\" for Darcy-Weisbach.\n    \"time_step\": <float>,   # Time step of network data. In per-unit (non-dimensionalized) or SI units.\n    \"viscosity\": <string>,  # Viscosity of water in the system. In per-unit (non-dimensionalized) or SI units.\n    \"node\": {\n        \"1\": {\n            \"index\": <int>,           # Index of the node, which should correspond to the key.\n            \"name\": <string>,         # Name of the node, which may or may not correspond to the index.\n            \"source_id\": <tuple>,     # Pair (e.g., [\"reservoir\", \"1\"]) describing where the node appears in the source file.\n            \"status\": <int>,          # Status of the node (-1 = unknown, 0 = inactive, 1 = active).\n            \"elevation\": <float>,     # Elevation of the node above some predefined datum. SI units are meters.\n            \"head_min\": <float>,      # Minimum total hydraulic head of the node. SI units are meters.\n            \"head_max\": <float>,      # Maximum total hydraulic head of the node. SI units are meters.\n            \"head_nominal\": <float>,  # Nominal total hydraulic head of the node. SI units are meters.\n            \"coordinates\": <tuple>    # Pair of coordinates (e.g., [-1.0, 1.0]) defining the graphical location of the node.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"demand\": {\n        \"1\": {\n            \"index\": <int>,          # Index of the demand, which should correspond to the key.\n            \"node\": <int>,           # Index of the node to which the demand is attached.\n            \"name\": <string>,        # Name of the demand, which may or may not correspond to the index.\n            \"source_id\": <tuple>,    # Pair (e.g., [\"demand\", \"1\"]) describing where the demand appears in the source file.\n            \"status\": <int>,         # Status of the demand (-1 = unknown, 0 = inactive, 1 = active).\n            \"dispatchable\": <bool>,  # Whether or not the demand can fluctuate (true) or if it is fixed (false).\n            \"flow_min\": <float>,     # Minimum volumetric flow rate demanded. SI units are cubic meters per second.\n            \"flow_max\": <float>,     # Maximum volumetric flow rate demanded. SI units are cubic meters per second.\n            \"flow_nominal\": <float>  # Nominal volumetric flow rate demanded. SI units are cubic meters per second.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"reservoir\": {\n        \"1\": {\n            \"index\": <int>,          # Index of the reservoir, which should correspond to the key.\n            \"node\": <int>,           # Index of the node to which the reservoir is attached.\n            \"name\": <string>,        # Name of the reservoir, which may or may not correspond to the index.\n            \"source_id\": <tuple>,    # Pair (e.g., [\"reservoir\", \"1\"]) describing where the reservoir appears in the source file.\n            \"status\": <int>,         # Status of the reservoir (-1 = unknown, 0 = inactive, 1 = active).\n            \"dispatchable\": <bool>,  # Whether or not the reservoir's head can fluctuate (true) or if it is fixed (false).\n            \"head_nominal\": <float>  # Nominal head of the reservoir's surface. SI units are meters.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"tank\": {\n        \"1\": {\n            \"index\": <int>,          # Index of the tank, which should correspond to the key.\n            \"node\": <int>,           # Index of the node to which the tank is attached.\n            \"name\": <string>,        # Name of the tank, which may or may not correspond to the index.\n            \"source_id\": <tuple>,    # Pair (e.g., [\"tank\", \"1\"]) describing where the tank appears in the source file.\n            \"status\": <int>,         # Status of the tank (-1 = unknown, 0 = inactive, 1 = active).\n            \"dispatchable\": <bool>,  # Whether or not the tank's head can fluctuate (true) or if it is fixed (false).\n            \"diameter\": <float>,     # Cross-sectional diameter of the cylindrical tank. SI units are meters.\n            \"min_vol\": <float>,      # Minimum water volume contained by the tank. SI units are cubic meters.\n            \"init_level\": <float>,   # Initial water level of the tank. SI units are meters.\n            \"min_level\": <float>,    # Minimum water level of the tank. SI units are meters.\n            \"max_level\": <float>     # Maximum water level of the tank. SI units are meters.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"pipe\": {\n        \"1\": {\n            \"index\": <int>,               # Index of the pipe, which should correspond to the key.\n            \"node_fr\": <int>,             # Index of the \"from\" node to which the pipe is connected.\n            \"node_to\": <int>,             # Index of the \"to\" node to which the pipe is connected.\n            \"name\": <string>,             # Name of the pipe, which may or may not correspond to the index.\n            \"source_id\": <tuple>,         # Pair (e.g., [\"pipe\", \"1\"]) describing where the pipe appears in the source file.\n            \"status\": <int>,              # Status of the pipe (-1 = unknown, 0 = inactive, 1 = active).\n            \"length\": <float>,            # Length of the pipe. SI units are meters.\n            \"diameter\": <float>,          # Interior (inner) diameter of the pipe. SI units are meters.\n            \"roughness\": <float>,         # Roughness of the pipe. SI units are meters if \"head_loss\" is \"D-W\" and unitless if \"H-W\".\n            \"flow_direction\": <int>,      # Direction of flow through the pipe (-1 = negative, 0 = unknown, 1 = positive).\n            \"flow_min\": <float>,          # Minimum volumetric flow rate through the pipe. SI units are cubic meters per second.\n            \"flow_max\": <float>,          # Maximum volumetric flow rate through the pipe. SI units are cubic meters per second.\n            \"flow_min_forward\": <float>,  # Minimum volumetric flow rate when positively-directed. SI units are cubic meters per second.\n            \"flow_max_reverse\": <float>,  # Maximum volumetric flow rate when negatively-directed. SI units are cubic meters per second.\n            \"minor_loss\": <float>         # Used for modeling other minor losses of the pipe. Unitless. Currently unused.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"des_pipe\": {\n        \"1\": {\n            \"index\": <int>,               # Index of the design pipe, which should correspond to the key.\n            \"node_fr\": <int>,             # Index of the \"from\" node to which the design pipe is connected.\n            \"node_to\": <int>,             # Index of the \"to\" node to which the design pipe is connected.\n            \"name\": <string>,             # Name of the design pipe, which may or may not correspond to the index.\n            \"source_id\": <tuple>,         # Pair (e.g., [\"pipe\", \"1\"]) describing where the design pipe appears in the source file.\n            \"status\": <int>,              # Status of the design pipe (-1 = unknown, 0 = inactive, 1 = active).\n            \"length\": <float>,            # Length of the design pipe. SI units are meters.\n            \"diameter\": <float>,          # Interior (inner) diameter of the design pipe. SI units are meters.\n            \"roughness\": <float>,         # Roughness of the design pipe. SI units are meters if \"head_loss\" is \"D-W\" and unitless if \"H-W\".\n            \"flow_direction\": <int>,      # Direction of flow through the design pipe (-1 = negative, 0 = unknown, 1 = positive).\n            \"flow_min\": <float>,          # Minimum volumetric flow rate through the design pipe. SI units are cubic meters per second.\n            \"flow_max\": <float>,          # Maximum volumetric flow rate through the design pipe. SI units are cubic meters per second.\n            \"flow_min_forward\": <float>,  # Minimum volumetric flow rate when positively-directed. SI units are cubic meters per second.\n            \"flow_max_reverse\": <float>,  # Maximum volumetric flow rate when negatively-directed. SI units are cubic meters per second.\n            \"minor_loss\": <float>,        # Used for modeling other minor losses of the design pipe. Unitless. Currently unused.\n            \"cost\": <float>               # Cost of constructing the design pipe, if selected. Standard units are of currency.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"short_pipe\": {\n        \"1\": {\n            \"index\": <int>,               # Index of the short pipe, which should correspond to the key.\n            \"node_fr\": <int>,             # Index of the \"from\" node to which the short pipe is connected.\n            \"node_to\": <int>,             # Index of the \"to\" node to which the short pipe is connected.\n            \"name\": <string>,             # Name of the short pipe, which may or may not correspond to the index.\n            \"source_id\": <tuple>,         # Pair (e.g., [\"short_pipe\", \"1\"]) describing where the short pipe appears in the source file.\n            \"status\": <int>,              # Status of the short pipe (-1 = unknown, 0 = inactive, 1 = active).\n            \"flow_direction\": <int>,      # Direction of flow through the short pipe (-1 = negative, 0 = unknown, 1 = positive).\n            \"flow_min\": <float>,          # Minimum volumetric flow rate through the short pipe. SI units are cubic meters per second.\n            \"flow_max\": <float>,          # Maximum volumetric flow rate through the short pipe. SI units are cubic meters per second.\n            \"flow_min_forward\": <float>,  # Minimum volumetric flow rate when positively-directed. SI units are cubic meters per second.\n            \"flow_max_reverse\": <float>,  # Maximum volumetric flow rate when negatively-directed. SI units are cubic meters per second.\n            \"minor_loss\": <float>         # Used for modeling other minor losses of the short pipe. Unitless. Currently unused.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"pump\": {\n        \"1\": {\n            \"index\": <int>,                   # Index of the pump, which should correspond to the key.\n            \"node_fr\": <int>,                 # Index of the \"from\" node to which the pump is connected.\n            \"node_to\": <int>,                 # Index of the \"to\" node to which the pump is connected.\n            \"name\": <string>,                 # Name of the pump, which may or may not correspond to the index.\n            \"source_id\": <tuple>,             # Pair (e.g., [\"pump\", \"1\"]) describing where the pump appears in the source file.\n            \"status\": <int>,                  # Status of the pump (-1 = unknown, 0 = inactive, 1 = active).\n            \"flow_direction\": <int>,          # Direction of flow through the pump (-1 = negative, 0 = unknown, 1 = positive).\n            \"flow_min\": <float>,              # Minimum volumetric flow rate through the pump. SI units are cubic meters per second.\n            \"flow_max\": <float>,              # Maximum volumetric flow rate through the pump. SI units are cubic meters per second.\n            \"flow_min_forward\": <float>,      # Minimum volumetric flow rate when positively-directed. SI units are cubic meters per second.\n            \"flow_max_reverse\": <float>,      # Maximum volumetric flow rate when negatively-directed. SI units are cubic meters per second.\n            \"head_curve_form\": <int>,         # Form of the head curve function used to model the pump. PUMP_QUADRATIC (0) models the head\n                                              # gain as a quadratic function. PUMP_BEST_EFFICIENCY_POINT (1) models the head gain as a\n                                              # quadratic function parameterized using the pump's best efficiency point. PUMP_EPANET (2)\n                                              # models the head gain similarly to the model of EPANET, i.e., a + b * q^c, where a, b, and\n                                              # c are fixed constants computed from flow-head gain data present in the \"head_curve\" list.\n                                              # PUMP_LINEAR_POWER (3) models the head gain function as PUMP_QUADRATIC but power linearly.\n            \"head_curve\": <List[...]>,        # List of tuples describing the head gain of the pump, where the first element of the tuple\n                                              # corresponds to a volumetric flow rate (in per-unit or SI units) and the second element of\n                                              # corresponds to the head gain resulting from that flow rate (in per-unit or SI units).\n            \"efficiency_curve\": <List[...]>,  # List of tuples describing the efficiency of the pump, where the first element of the tuple\n                                              # corresponds to a volumetric flow rate (in per-unit or SI units) and the second element\n                                              # corresponds to the pump's power efficiency at that flow rate (a unitless quantity).\n            \"energy_price\": <float>,          # Cost of consuming energy (in per-unit or, for SI units, currency per Joule).\n            \"power_fixed\": <float>,           # When modeling the pump using PUMP_LINEAR_POWER for \"head_curve_form\", this quantity\n                                              # represents the power consumed by the pump at zero volumetric flow. SI units are Watts.\n            \"power_per_unit_flow\": <float>,   # When modeling the pump using PUMP_LINEAR_POWER for \"head_curve_form\", this quantity\n                                              # represents the power consumed per additional unit of flow. SI units are Watts per\n                                              # (cubic meters per second).\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"valve\": {\n        \"1\": {\n            \"index\": <int>,               # Index of the valve, which should correspond to the key.\n            \"node_fr\": <int>,             # Index of the \"from\" node to which the valve is connected.\n            \"node_to\": <int>,             # Index of the \"to\" node to which the valve is connected.\n            \"name\": <string>,             # Name of the valve, which may or may not correspond to the index.\n            \"source_id\": <tuple>,         # Pair (e.g., [\"pipe\", \"1\"]) describing where the valve appears in the source file.\n            \"status\": <int>,              # Status of the valve (-1 = unknown, 0 = inactive, 1 = active).\n            \"flow_direction\": <int>,      # Direction of flow through the valve (-1 = negative, 0 = unknown, 1 = positive).\n            \"flow_min\": <float>,          # Minimum volumetric flow rate through the valve. SI units are cubic meters per second.\n            \"flow_max\": <float>,          # Maximum volumetric flow rate through the valve. SI units are cubic meters per second.\n            \"flow_min_forward\": <float>,  # Minimum volumetric flow rate when positively-directed. SI units are cubic meters per second.\n            \"flow_max_reverse\": <float>,  # Maximum volumetric flow rate when negatively-directed. SI units are cubic meters per second.\n            \"minor_loss\": <float>         # Used for modeling other minor losses of the valve. Unitless. Currently unused.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"regulator\": {\n        \"1\": {\n            \"index\": <int>,               # Index of the regulator, which should correspond to the key.\n            \"node_fr\": <int>,             # Index of the \"from\" node to which the regulator is connected.\n            \"node_to\": <int>,             # Index of the \"to\" node to which the regulator is connected.\n            \"name\": <string>,             # Name of the regulator, which may or may not correspond to the index.\n            \"source_id\": <tuple>,         # Pair (e.g., [\"regulator\", \"1\"]) describing where the regulator appears in the source file.\n            \"status\": <int>,              # Status of the regulator (-1 = unknown, 0 = inactive, 1 = active).\n            \"flow_direction\": <int>,      # Direction of flow through the regulator (-1 = negative, 0 = unknown, 1 = positive).\n            \"diameter\": <float>,          # (Possibly artificial) diameter of the regulator. SI units are meters. Currently unused.\n            \"setting\": <float>,           # Setting of the total hydraulic head at the node downstream of the regulator. SI units are meters.\n            \"flow_min\": <float>,          # Minimum volumetric flow rate through the regulator. SI units are cubic meters per second.\n            \"flow_max\": <float>,          # Maximum volumetric flow rate through the regulator. SI units are cubic meters per second.\n            \"flow_min_forward\": <float>,  # Minimum volumetric flow rate when positively-directed. SI units are cubic meters per second.\n            \"flow_max_reverse\": <float>,  # Maximum volumetric flow rate when negatively-directed. SI units are cubic meters per second.\n            \"minor_loss\": <float>         # Used for modeling other minor losses of the regulator. Unitless. Currently unused.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    }\n}","category":"page"},{"location":"network-data.html#Multinetwork-(Time-Series)-Data","page":"Network Data Format","title":"Multinetwork (Time Series) Data","text":"","category":"section"},{"location":"network-data.html","page":"Network Data Format","title":"Network Data Format","text":"The Network Data Dictionary outlines the hierarchy for a snapshot of data for a water network at some moment in time. In practice, water network optimization problems often model evolution of the system over time. To model temporal aspects, a similar data hierarchy is used. These \"multinetwork\" dictionaries are of the form","category":"page"},{"location":"network-data.html","page":"Network Data Format","title":"Network Data Format","text":"{\n    \"name\": <string>,\n    \"multinetwork\": true,\n    \"per_unit\": <bool>,\n    ...,\n    \"nw\": {\n        \"1\": {\n            \"name\": <string>,\n            \"time_step\": <float>,\n            \"node\": {\n                \"1\": {\n                    ...\n                },\n                ...\n            },\n            ...\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    }\n}","category":"page"},{"location":"network-data.html","page":"Network Data Format","title":"Network Data Format","text":"That is, the component dictionaries, i.e., [\"tank\", \"regulator\", \"pump\", \"name\", \"des_pipe\", \"demand\", \"reservoir\", \"short_pipe\", \"node\", \"valve\", \"pipe\"], as well as the \"time_step\" and \"name\" parameters are stored within an indexed \"nw\" subdictionary. Here, the \"1\" subdictionary of \"nw\" might represent the network at the first time index in the model of interest, and \"2\" might represent the network at the second time index.","category":"page"},{"location":"developer.html#Developer-Documentation","page":"Developer","title":"Developer Documentation","text":"","category":"section"},{"location":"developer.html#Variable,-Constraint,-and-Parameter-Naming","page":"Developer","title":"Variable, Constraint, and Parameter Naming","text":"","category":"section"},{"location":"developer.html#Suffixes","page":"Developer","title":"Suffixes","text":"","category":"section"},{"location":"developer.html","page":"Developer","title":"Developer","text":"_des: used to denote a concept specific to network design problems\n_on_off: used to denote a concept where there are either-or choices, such as pump operations","category":"page"},{"location":"developer.html#Total-Hydraulic-Head","page":"Developer","title":"Total Hydraulic Head","text":"","category":"section"},{"location":"developer.html","page":"Developer","title":"Developer","text":"h: total hydraulic head\ndh: difference in head between nodes\ndhp: (nonnegative) difference in head between tail and head nodes\ndhn: (nonnegative) difference in head between head and tail nodes","category":"page"},{"location":"developer.html#Volumetric-Flow-Rate","page":"Developer","title":"Volumetric Flow Rate","text":"","category":"section"},{"location":"developer.html","page":"Developer","title":"Developer","text":"q: volumetric flow rate (\"flow\"), which can be negative or nonnegative\nqp: positively-directed flow magnitude (i.e., flow transported from node_fr to node_to)\nqn: negatively-directed flow magnitude (i.e., flow transported from node_to to node_fr)","category":"page"},{"location":"parser.html#File-I/O","page":"File I/O","title":"File I/O","text":"","category":"section"},{"location":"parser.html","page":"File I/O","title":"File I/O","text":"CurrentModule = WaterModels","category":"page"},{"location":"parser.html#General-Parsing-Function","page":"File I/O","title":"General Parsing Function","text":"","category":"section"},{"location":"parser.html","page":"File I/O","title":"File I/O","text":"WaterModels supports two input file formats: JavaScript Object Notation (JSON) and EPANET input file formats. The function below parses an input file based on its extension and returns a WaterModels data model in the form of a dictionary.","category":"page"},{"location":"parser.html","page":"File I/O","title":"File I/O","text":"parse_file","category":"page"},{"location":"parser.html#WaterModels.parse_file","page":"File I/O","title":"WaterModels.parse_file","text":"parse_file(\n    path::String;\n    skip_correct::Bool=false,\n    per_unit::Bool=true\n)\n\nParses an EPANET (.inp) or JavaScript Object Notation (JSON) file from the file path path, depending on the file extension, and returns a WaterModels data structure (i.e., a dictionary of data). Here, skip_correct will skip data correction routines (e.g., component status propagation) if set to true, and per_unit will translate the data model to a per-unit measurement system if set to true.\n\n\n\n\n\n","category":"function"},{"location":"parser.html#General-Data-Formats","page":"File I/O","title":"General Data Formats","text":"","category":"section"},{"location":"parser.html","page":"File I/O","title":"File I/O","text":"The JavaScript Object Notation (JSON) file format is a direct serialization of WaterModels' internal data model. As such, the JSON file format is intended to be a temporary storage format. WaterModels does not maintain backward compatibility with serializations of earlier versions of the WaterModels data model.","category":"page"},{"location":"parser.html","page":"File I/O","title":"File I/O","text":"parse_json","category":"page"},{"location":"parser.html#WaterModels.parse_json","page":"File I/O","title":"WaterModels.parse_json","text":"parse_json(path::String)\n\nParses a JavaScript Object Notation (JSON) file from the file path path and returns a WaterModels data structure (i.e., a dictionary of data). Does not perform data correction nor per-unit translations of the data model.\n\n\n\n\n\n","category":"function"},{"location":"parser.html#EPANET-Data-Files","page":"File I/O","title":"EPANET Data Files","text":"","category":"section"},{"location":"parser.html","page":"File I/O","title":"File I/O","text":"The EPANET (.inp) file format is the de facto standard for representing water networks. The function below parses the EPANET file at path path and returns a WaterModels data structure (a dictionary of data). See the OpenWaterAnalytics Wiki for a description of the EPANET format. Note also that this parsing routine does not preserve topology nor one-to-one correspondence with the original EPANET model. As one example, each pipe with a valve (check or shutoff) is transformed into a WaterModels pipe component and a valve component. As another example, WaterModels \"nodes\" are points at which junctions, reservoirs, or tanks appear in the EPANET model. In the WaterModels data model, junctions, reservoirs, and tanks are considered as \"attached\" to nodes.","category":"page"},{"location":"parser.html","page":"File I/O","title":"File I/O","text":"parse_epanet","category":"page"},{"location":"parser.html#WaterModels.parse_epanet","page":"File I/O","title":"WaterModels.parse_epanet","text":"parse_epanet(path::String)\n\nParses an EPANET (.inp) file from the file path path and returns a WaterModels data structure (a dictionary of data). See the OpenWaterAnalytics Wiki for a thorough description of the EPANET format and its components. Note also that this parsing routine does not necessarily preserve topology nor one-to-one correspondence with the original EPANET model, e.g., each pipe with a valve (check or shutoff) is transformed into a WaterModels pipe component and a valve component. Does not perform data correction nor per-unit translations of the data model.\n\n\n\n\n\n","category":"function"},{"location":"quickguide.html#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The following guide walks through the solution of a water network design (des) problem using two mixed-integer linear programming (MILP) formulations (PWLRD and LRD) of the problem specification. This is to enable solution using the readily-available open-source MILP solver HiGHS. Other formulations rely on the availability of mixed-integer nonlinear programming (MINLP) solvers that support user-defined nonlinear functions in JuMP. However, these solvers (e.g., Juniper, KNITRO) either require additional effort to register user-defined functions or are proprietary and require a commercial license.","category":"page"},{"location":"quickguide.html#Installation-of-WaterModels","page":"Getting Started","title":"Installation of WaterModels","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The latest stable release of WaterModels can be installed using the Julia package manager with","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"] add WaterModels","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"For the current development version, install the package using","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"] add WaterModels#master","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"Finally, test that the package works as expected by executing","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"] test WaterModels","category":"page"},{"location":"quickguide.html#Installation-of-an-Optimization-Solver","page":"Getting Started","title":"Installation of an Optimization Solver","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"At least one optimization solver is required to run WaterModels. The solver selected typically depends on the type of problem formulation being employed. Because in this example, we will be studying the linearization-based PWLRD and LRD formulations, we will leverage the open-source MILP solver HiGHS. Installation of the JuMP interface to HiGHS can be performed via the Julia package manager, i.e.,","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"] add HiGHS","category":"page"},{"location":"quickguide.html#Solving-a-Network-Design-Problem","page":"Getting Started","title":"Solving a Network Design Problem","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"Once the above dependencies have been installed, obtain the file shamir.json. Here, shamir.json is a JSON file specifying the network, as well as possible pipe diameters and associated costs, per diameter setting. The file provides the required information to set up a corresponding network design problem, where the goal is to select the most cost-efficient pipe diameters while satisfying all demand in the network.","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"To read in the data, execute the following:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"using WaterModels\ndata = parse_file(\"examples/data/json/shamir.json\")","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"Since we are using a linearization-based formulation of the problem, it is important to specify the partitioning of flows that parameterize the formulation. Here, we initialize linearization flow partitions that assume a head loss error tolerance of fifty meters, with widths between flow points no greater than 1.0e-4 cubic meters per second:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"set_flow_partitions_si!(data, 50.0, 1.0e-4)","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"Finally, the PWLRD formulation for the network design specification can be solved using","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"import HiGHS\nsolve_des(data, PWLRDWaterModel, HiGHS.Optimizer)","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The above flow partitioning, however, is somewhat coarse, and the number of points in each partition is typically three, e.g.,","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"data[\"des_pipe\"][\"3\"][\"flow_partition\"]","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The relaxation can be more finely discretized by using a smaller head loss error tolerance, e.g.,","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"set_flow_partitions_si!(data, 5.0, 1.0e-4)","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"We can then solve the problem with the updated partitioning scheme via","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"import JuMP\nhighs = JuMP.optimizer_with_attributes(HiGHS.Optimizer, \"time_limit\" => 30.0)\nsolve_des(data, PWLRDWaterModel, highs)","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"Note that this formulation takes much longer to solve to global optimality due to the use of more binary variables. However, because of the finer discretization, a better approximation of the physics is attained.","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"Instead of using piecewise-linear envelopes, head loss curves can also be simply outer-approximated via the LRD formulation. This formulation employs less strict requirements and avoids the use of binary variables for piecewise approximation, but solutions (e.g., diameters) may not be as close to feasibility with respect to the full (nonconvex) water network physics. To solve an LRD formulation of the problem using an even finer flow partitioning scheme (but without piecewise inner head loss approximations), the following can be executed:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"set_flow_partitions_si!(data, 0.5, 1.0e-4)\nsolve_des(data, LRDWaterModel, HiGHS.Optimizer)","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"This relaxation of the problem turns out to converge to the known globally optimal objective value.","category":"page"},{"location":"quickguide.html#Obtaining-Results","page":"Getting Started","title":"Obtaining Results","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"For the rest of this tutorial, we will first assume a coarser relaxation by resetting the flow partitions as","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"set_flow_partitions_si!(data, 50.0, 1.0e-4)","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The solve commands in WaterModels return detailed results data in the form of a Julia Dict. This dictionary can be saved for further processing as follows:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"result = solve_des(data, LRDWaterModel, HiGHS.Optimizer)","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"For example, the algorithm's runtime and final objective value can be accessed with","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"result[\"solve_time\"] # Total solve time required (seconds).\nresult[\"objective\"] # Final objective value (in units of the objective).","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The \"solution\" field contains detailed information about the solution produced by the solve method. For example, the following dictionary comprehension can be used to inspect the flows in the solution:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"flows = Dict(name => data[\"q\"] for (name, data) in result[\"solution\"][\"des_pipe\"])","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"To determine the design pipes that were selected via the optimization, the following can be used:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"pipes_selected = filter(x -> x.second[\"status\"] == 1, result[\"solution\"][\"des_pipe\"])","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"To retrieve the subset of the original pipe dataset, the following can be used:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"pipes_subset = filter(x -> x.first in keys(pipes_selected), data[\"des_pipe\"])","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"For more information about WaterModels result data see the WaterModels Result Data Format section.","category":"page"},{"location":"quickguide.html#Accessing-Different-Formulations","page":"Getting Started","title":"Accessing Different Formulations","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The MILP formulations discussed above assume access to a MILP solver. Nonconvex MINLP formulations can be solved with dedicated solvers, as well. For example, the nonconvex MINLP formulation for design (NC) can be solved via","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"import KNITRO\nsolve_des(data, NCWaterModel, KNITRO.Optimizer)","category":"page"},{"location":"quickguide.html#Modifying-Network-Data","page":"Getting Started","title":"Modifying Network Data","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates one way to perform multiple WaterModels solves while modifying network data:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"solve_des(data, LRDWaterModel, HiGHS.Optimizer)\n\ndata[\"demand\"][\"3\"][\"flow_min\"] *= 0.5\ndata[\"demand\"][\"3\"][\"flow_max\"] *= 0.5\ndata[\"demand\"][\"3\"][\"flow_nominal\"] *= 0.5\n\nsolve_des(data, LRDWaterModel, HiGHS.Optimizer)","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"Note that the smaller demands in the second problem result in an overall smaller design cost. For additional details about the network data, see the WaterModels Network Data Format section.","category":"page"},{"location":"quickguide.html#Alternative-Methods-for-Building-and-Solving-Models","page":"Getting Started","title":"Alternative Methods for Building and Solving Models","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates how to break a solve_des call into separate model building and solving steps. This allows inspection of the JuMP model created by WaterModels for the problem.","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"wm = instantiate_model(data, LRDWaterModel, WaterModels.build_des);\n\nprintln(wm.model)\n\nresult = optimize_model!(wm, optimizer = HiGHS.Optimizer)","category":"page"},{"location":"quickguide.html#Solution-Unit-Conversion","page":"Getting Started","title":"Solution Unit Conversion","text":"","category":"section"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"The default behavior of WaterModels produces solution results in non-dimensionalized units. To recover solutions in SI units, the following function can be used:","category":"page"},{"location":"quickguide.html","page":"Getting Started","title":"Getting Started","text":"make_si_units!(result[\"solution\"])","category":"page"},{"location":"constraints.html#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"CurrentModule = WaterModels","category":"page"},{"location":"constraints.html#Constraint-Templates","page":"Constraints","title":"Constraint Templates","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"Constraint templates help simplify data wrangling across multiple optimization formulations by providing an abstraction layer between the network data and network constraint definitions. Each constraint template's job is to extract the required parameters from a given network data structure and pass the data as arguments to the optimization formulation. These templates should be defined over AbstractWaterModel and should not refer to model variables. For more details, see the files core/constraint_template.jl and core/constraint.jl. Here, core/constraint_template.jl provides higher-level constraint interfaces by processing network data and calling methods defined in core/constraint.jl.","category":"page"},{"location":"constraints.html#Nodal-Constraints","page":"Constraints","title":"Nodal Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"constraint_flow_conservation\nconstraint_node_directionality\nconstraint_sink_directionality\nconstraint_source_directionality\nconstraint_intermediate_directionality","category":"page"},{"location":"constraints.html#WaterModels.constraint_flow_conservation","page":"Constraints","title":"WaterModels.constraint_flow_conservation","text":"constraint_flow_conservation(\n    wm::AbstractWaterModel,\n    n::Int,\n    i::Int,\n    pipe_fr::Array{Int,1},\n    pipe_to::Array{Int,1},\n    des_pipe_fr::Array{Int,1},\n    des_pipe_to::Array{Int,1},\n    pump_fr::Array{Int,1},\n    pump_to::Array{Int,1},\n    regulator_fr::Array{Int,1},\n    regulator_to::Array{Int,1},\n    short_pipe_fr::Array{Int,1},\n    short_pipe_to::Array{Int,1},\n    valve_fr::Array{Int,1},\n    valve_to::Array{Int,1},\n    reservoirs::Array{Int,1},\n    tanks::Array{Int,1},\n    dispatchable_demands::Array{Int,1},\n    fixed_demand::Float64\n)\n\nAdds a constraint that ensures volumetric flow rate (and thus mass) is conserved at node i and subnetwork (or time) index n in the network. Here, pipe_fr, pipe_to, etc., are components that are directed from or to node i, respectively. Additionally, reservoirs, tanks, and dispatchable_demands are node-attached components that variably contribute to nodal inflow and outflow at node i. Finally, fixed_demand is the fixed amount of flow demanded at node i, which may be negative or nonnegative.\n\n\n\n\n\nconstraint_flow_conservation(\n    wm::AbstractWaterModel,\n    i::Int;\n    nw::Int=nw_id_default\n)\n\nConstraint template to add constraints that ensure volumetric flow rate (and thus mass) is conserved at node i and subnetwork (or time) index nw in the network. Here, wm is the WaterModels object.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_node_directionality","page":"Constraints","title":"WaterModels.constraint_node_directionality","text":"constraint_node_directionality(\n    wm::AbstractWaterModel,\n    i::Int;\n    nw::Int=nw_id_default\n)\n\nConstraint template to add direction-based constraints (constraint_sink_directionality, constraint_source_directionality, or constraint_intermediate_directionality) when appropriate. Here, wm is the WaterModels object, i is the index of the node for which the constraints will be added, if applicable, and nw is the subnetwork (or time) index.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_sink_directionality","page":"Constraints","title":"WaterModels.constraint_sink_directionality","text":"constraint_sink_directionality(\n    wm::AbstractNCModel,\n    n::Int,\n    i::Int,\n    pipe_fr::Array{Int,1},\n    pipe_to::Array{Int,1},\n    des_pipe_fr::Array{Int,1},\n    des_pipe_to::Array{Int,1},\n    pump_fr::Array{Int,1},\n    pump_to::Array{Int,1},\n    regulator_fr::Array{Int,1},\n    regulator_to::Array{Int,1},\n    short_pipe_fr::Array{Int,1},\n    short_pipe_to::Array{Int,1},\n    valve_fr::Array{Int,1},\n    valve_to::Array{Int,1}\n)\n\nCurrently does nothing for models of type AbstractNCModel. Here, wm is the WaterModels object; n is the subnetwork (time) index; i is the index of the node; and pipe_fr, pipe_to, etc., are indices of node-connecting components that are directed from or to node i, respectively.\n\n\n\n\n\nconstraint_sink_directionality(\n    wm::AbstractNCDModel,\n    n::Int,\n    i::Int,\n    pipe_fr::Array{Int,1},\n    pipe_to::Array{Int,1},\n    des_pipe_fr::Array{Int,1},\n    des_pipe_to::Array{Int,1},\n    pump_fr::Array{Int,1},\n    pump_to::Array{Int,1},\n    regulator_fr::Array{Int,1},\n    regulator_to::Array{Int,1},\n    short_pipe_fr::Array{Int,1},\n    short_pipe_to::Array{Int,1},\n    valve_fr::Array{Int,1},\n    valve_to::Array{Int,1}\n)\n\nAdds a constraint that ensures at least one flow direction variable implies the transport of water to (i.e., into) a node that has flow demands (e.g., a node with positive fixed demands). Here, n is the subnetwork (time) index; i is the index of the node; and pipe_fr, pipe_to, etc., are indices of node- connecting components that are directed from or to node i, respectively.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_source_directionality","page":"Constraints","title":"WaterModels.constraint_source_directionality","text":"constraint_source_directionality(\n    wm::AbstractNCModel,\n    n::Int,\n    i::Int,\n    pipe_fr::Array{Int,1},\n    pipe_to::Array{Int,1},\n    des_pipe_fr::Array{Int,1},\n    des_pipe_to::Array{Int,1},\n    pump_fr::Array{Int,1},\n    pump_to::Array{Int,1},\n    regulator_fr::Array{Int,1},\n    regulator_to::Array{Int,1},\n    short_pipe_fr::Array{Int,1},\n    short_pipe_to::Array{Int,1},\n    valve_fr::Array{Int,1},\n    valve_to::Array{Int,1}\n)\n\nCurrently does nothing for models of type AbstractNCModel. Here, wm is the WaterModels object; n is the subnetwork (time) index; i is the index of the node; and pipe_fr, pipe_to, etc., are indices of node-connecting components that are directed from or to node i, respectively.\n\n\n\n\n\nconstraint_source_directionality(\n    wm::AbstractNCDModel,\n    n::Int,\n    i::Int,\n    pipe_fr::Array{Int,1},\n    pipe_to::Array{Int,1},\n    des_pipe_fr::Array{Int,1},\n    des_pipe_to::Array{Int,1},\n    pump_fr::Array{Int,1},\n    pump_to::Array{Int,1},\n    regulator_fr::Array{Int,1},\n    regulator_to::Array{Int,1},\n    short_pipe_fr::Array{Int,1},\n    short_pipe_to::Array{Int,1},\n    valve_fr::Array{Int,1},\n    valve_to::Array{Int,1}\n)\n\nAdds a constraint that ensures at least one flow direction variable implies the transport of water from (i.e., out of) a source node (e.g., a node with a reservoir). Here, n is the subnetwork (time) index; i is the index of the node; and pipe_fr, pipe_to, etc., are indices of node-connecting components that are directed from or to node i, respectively.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_intermediate_directionality","page":"Constraints","title":"WaterModels.constraint_intermediate_directionality","text":"constraint_intermediate_directionality(\n    wm::AbstractNCModel,\n    n::Int,\n    i::Int,\n    pipe_fr::Array{Int,1},\n    pipe_to::Array{Int,1},\n    des_pipe_fr::Array{Int,1},\n    des_pipe_to::Array{Int,1},\n    pump_fr::Array{Int,1},\n    pump_to::Array{Int,1},\n    regulator_fr::Array{Int,1},\n    regulator_to::Array{Int,1},\n    short_pipe_fr::Array{Int,1},\n    short_pipe_to::Array{Int,1},\n    valve_fr::Array{Int,1},\n    valve_to::Array{Int,1}\n)\n\nCurrently does nothing for models of type AbstractNCModel. Here, wm is the WaterModels object; n is the subnetwork (time) index; i is the index of the node; and pipe_fr, pipe_to, etc., are indices of node-connecting components that are directed from or to node i, respectively.\n\n\n\n\n\nconstraint_intermediate_directionality(\n    wm::AbstractNCDModel,\n    n::Int,\n    i::Int,\n    pipe_fr::Array{Int,1},\n    pipe_to::Array{Int,1},\n    des_pipe_fr::Array{Int,1},\n    des_pipe_to::Array{Int,1},\n    pump_fr::Array{Int,1},\n    pump_to::Array{Int,1},\n    regulator_fr::Array{Int,1},\n    regulator_to::Array{Int,1},\n    short_pipe_fr::Array{Int,1},\n    short_pipe_to::Array{Int,1},\n    valve_fr::Array{Int,1},\n    valve_to::Array{Int,1}\n)\n\nAdds a constraint that ensures the direction of incoming flow at the node will be equal to the direction of outgoing flow. Note that this constraint should only be applied in situations where the degree of the node is two and there is zero supply or demand (i.e., the node is a \"junction\" or pass-through node). Here, n is the subnetwork (time) index; i is the index of the node; and pipe_fr, pipe_to, etc., are indices of node-connecting components that are directed from or to node i, respectively.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Tank-Constraints","page":"Constraints","title":"Tank Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"constraint_tank_volume\nconstraint_tank_volume_fixed\nconstraint_tank_volume_recovery","category":"page"},{"location":"constraints.html#WaterModels.constraint_tank_volume","page":"Constraints","title":"WaterModels.constraint_tank_volume","text":"constraint_tank_volume(\n    wm::AbstractWaterModel,\n    n_1::Int,\n    n_2::Int,\n    i::Int,\n    time_step::Float64\n)\n\nAdds a constraint that integrates the volume of a tank forward in time. Here, wm is the WaterModels object, n_1 is the index of a subnetwork within a multinetwork, n_2 is the index of another subnetwork forward in time, relative to n_1, i is the index of the tank, and time_step is the time step of the interval from network n_1 to n_2.\n\n\n\n\n\nconstraint_tank_volume(\n    wm::AbstractWaterModel,\n    i::Int;\n    nw::Int=nw_id_default\n)\n\nConstraint template to add constraint_tank_volume_fixed constraints when a tank is not dispatchable, usually at the first time index of a problem to fix the tank's initial volume. Here, wm is the WaterModels object, i is the index of the tank for which the constraints will be added, if applicable, and nw is the subnetwork (or time) index at which the volume will be fixed.\n\n\n\n\n\nconstraint_tank_volume(\n    wm::AbstractWaterModel,\n    i::Int,\n    nw_1::Int,\n    nw_2::Int\n)\n\nConstraint template to add constraint_tank_volume constraints that integrate the volume of a tank forward in time. Here, wm is the WaterModels object, i is the index of the tank for which the constraints will be added, nw_1 is the first time index considered in the temporal integration, and nw_2 is the adjacent (second) time index considered in the integration.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_tank_volume_fixed","page":"Constraints","title":"WaterModels.constraint_tank_volume_fixed","text":"constraint_tank_volume_fixed(\n    wm::AbstractWaterModel,\n    n::Int,\n    i::Int,\n    V_0::Float64,\n    time_step::Float64,\n    min_vol::Float64,\n    max_vol::Float64\n)\n\nAdds a constraint that ensures the volume of a tank at some time index is fixed. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, i is the index of the tank, and V_0 is the fixed volume of the tank that is desired. Also adds constraints that ensure, after integration of volume forward in time, the new volume will reside between predefined lower and upper bounds. To that end, time_step is the time step between the current time index and the next, min_vol is the minimum volume of water that must be present in the tank, and max_vol is the maximum volume of water in the tank.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_tank_volume_recovery","page":"Constraints","title":"WaterModels.constraint_tank_volume_recovery","text":"constraint_tank_volume_recovery(\n    wm::AbstractWaterModel,\n    i::Int,\n    n_1::Int,\n    n_f::Int\n)\n\nAdds a constraint that ensures the volume of a tank at the end of the time horizon is greater than or equal to the volume of the tank at the beginning of the time horizon. Here, wm is the WaterModels object, i is the index of the tank, n_1 is the index of the first subnetwork within a multinetwork, and n_f is the index of the final subnetwork. Also updates the minimum head in the ref dictionary for node i at the final subnetwork index n_f to take the minimum head value at n_1 if it is larger, as implied by this constraint.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Pipe-Constraints","page":"Constraints","title":"Pipe Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"constraint_pipe_flow\nconstraint_pipe_head\nconstraint_pipe_head_loss","category":"page"},{"location":"constraints.html#WaterModels.constraint_pipe_flow","page":"Constraints","title":"WaterModels.constraint_pipe_flow","text":"constraint_pipe_flow(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_pipe_flow constraints that limit the volumetric flow rate across a pipe. Here, wm is the WaterModels object, a is the index of the pipe for which flow will be limited, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_pipe_flow(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nCurrently does nothing for models of type AbstractNCModel. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pipe for which flow will be limited, q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction), and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. For AbstractNCModel types, no constraints will be added, as in these formulation types, flow is not partitioned by direction, and flow bounds are instead imposed during variable instantiation in variable_flow.\n\n\n\n\n\nconstraint_pipe_flow(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow traveling in the positive (forward) and negative (reverse) directions. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, a is the index of the pipe, q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction), and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. Note that, naively, q_max_reverse and q_min_forward could both be assumed as zero, but the introduction of these constants allows for strengthening of flow direction variable bounds based on the binary flow direction variables used here.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_pipe_head","page":"Constraints","title":"WaterModels.constraint_pipe_head","text":"constraint_pipe_head(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_pipe_head constraints that limit and establish relationships among head difference and head variables. Here, wm is the WaterModels object, a is the index of the pipe, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_pipe_head(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int\n)\n\nAdd constraints that limit the head difference (loss) along a pipe based on the lower and upper bounds of head variables at the nodes connecting that pipe. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pipe, node_fr is the index of the tail node of the pipe, and node_to is the index of the head node of the pipe.\n\n\n\n\n\nconstraint_pipe_head(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n)\n\nAdds constraints that limit head losses (differences) in the positive (forward) and negative (reverse) flow directions. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, a is the index of the pipe, node_fr is the index of the tail node of the arc that models the pipe, and node_to is the index of the head node of the arc that models the pipe.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_pipe_head_loss","page":"Constraints","title":"WaterModels.constraint_pipe_head_loss","text":"constraint_pipe_head_loss(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_pipe_head_loss constraints that model head loss relationships along a pipe. Here, wm is the WaterModels object, a is the index of the pipe, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_pipe_head_loss(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdd constraints that model frictional head loss across a pipe. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the pipe; node_fr is the index of the tail node of the pipe; node_to is the index of the head node of the pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy-Weisbach head loss); L is the length of the pipe; r is the resistance per unit length of the pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction.\n\n\n\n\n\nconstraint_pipe_head_loss(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdd constraints that model frictional head loss across a pipe. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the pipe; node_fr is the index of the tail node of the pipe; node_to is the index of the head node of the pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy-Weisbach head loss); L is the length of the pipe; r is the resistance per unit length of the pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction.\n\n\n\n\n\nconstraint_pipe_head_loss(\n    wm::AbstractLAModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that model frictional head loss across a pipe via a piecewise- linear approximation of the nonlinear, nonconvex head loss relationship. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the pipe; node_fr is the index of the tail node of the pipe; node_to is the index of the head node of the pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy-Weisbach head loss); L is the length of the pipe; r is the resistance per unit length of the pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. Note that q_max_reverse and q_min_forward are unused in this formulation since it is not direction-based.\n\n\n\n\n\nconstraint_pipe_head_loss(\n    wm::AbstractPWLRDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that model frictional head loss across a pipe via outer and piecewise-linear inner approximations of the nonlinear, nonconvex head loss relationship. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the pipe; node_fr is the index of the tail node of the pipe; node_to is the index of the head node of the pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy-Weisbach head loss); L is the length of the pipe; r is the resistance per unit length of the pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction.\n\n\n\n\n\nconstraint_pipe_head_loss(\n    wm::AbstractLRDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that model frictional head loss across a pipe via linear outer approximations of the nonlinear, nonconvex head loss relationship. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the pipe; node_fr is the index of the tail node of the pipe; node_to is the index of the head node of the pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy-Weisbach head loss); L is the length of the pipe; r is the resistance per unit length of the pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Design-Pipe-Constraints","page":"Constraints","title":"Design Pipe Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"constraint_des_pipe_flow\nconstraint_des_pipe_head\nconstraint_on_off_des_pipe_flow\nconstraint_on_off_des_pipe_head\nconstraint_on_off_des_pipe_head_loss\nconstraint_des_pipe_selection","category":"page"},{"location":"constraints.html#WaterModels.constraint_des_pipe_flow","page":"Constraints","title":"WaterModels.constraint_des_pipe_flow","text":"constraint_des_pipe_flow(\n    wm::AbstractWaterModel,\n    k::Int,\n    node_fr::Int,\n    node_to::Int;\n    nw::Int=nw_id_default,\n    kwargs...,\n)\n\nConstraint template to add constraints that ensure flow variables for design pipes along an arc are equally directed (for direction-based formulations). Here, wm is the WaterModels object, k is the index of the arc that connects the two common nodes of each design pipe, node_fr is the index of the tail node of the arc that models each design pipe, node_to is the index of the head node of the arc that models each design pipe, nw is the index of a subnetwork within a multinetwork, and des_pipes is the vector of design pipe indices for design pipes that reside along the same arc k.\n\n\n\n\n\nconstraint_des_pipe_flow(\n    wm::AbstractNCModel,\n    n::Int,\n    k::Int,\n    node_fr::Int,\n    node_to::Int,\n    des_pipes::Array{Int,1}\n)\n\nCurrently does nothing for models of type AbstractNCModel. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, k is the index of the arc that connects the two common nodes of each design pipe, node_fr is the index of the tail node of the arc that models each design pipe, node_to is the index of the head node of the arc that models each design pipe, and des_pipes is the vector of design pipes that reside along the same arc k. For AbstractNCModel types, no constraints will be added, as in these formulation types, flow is not partitioned by direction, and flow bounds are instead imposed during variable instantiation in variable_flow.\n\n\n\n\n\nconstraint_des_pipe_flow(\n    wm::AbstractNCDModel,\n    n::Int,\n    k::Int,\n    node_fr::Int,\n    node_to::Int,\n    des_pipes::Array{Int,1}\n)\n\nAdds constraint that ensures direction variables for all design pipes along an arc are equal to one another. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, k is the index of the arc that connects the two common nodes of each design pipe, node_fr is the index of the tail node of the arc that models each design pipe, node_to is the index of the head node of the arc that models each design pipe, and des_pipes is the vector of design pipes that reside along the same arc k.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_des_pipe_head","page":"Constraints","title":"WaterModels.constraint_des_pipe_head","text":"constraint_des_pipe_head(\n    wm::AbstractWaterModel,\n    k::Int,\n    node_fr::Int,\n    node_to::Int;\n    nw::Int=nw_id_default,\n    kwargs...,\n)\n\nConstraint template to add constraints that ensure head difference variables for design pipes along an arc sum to the actual head difference along that arc. Here, wm is the WaterModels object, k is the index of the arc that connects the two common nodes of each design pipe, node_fr is the index of the tail node of the arc that models each design pipe, node_to is the index of the head node of the arc that models each design pipe, nw is the index of a subnetwork within a multinetwork, and des_pipes is the vector of design pipe indices for design pipes that reside along the same arc k.\n\n\n\n\n\nconstraint_des_pipe_head(\n    wm::AbstractNCModel,\n    n::Int,\n    k::Int,\n    node_fr::Int,\n    node_to::Int,\n    des_pipes::Array{Int,1}\n)\n\nAdds constraint that ensures head difference variables for design pipes along an arc sum to the actual head difference along that single arc. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, k is the index of the arc that connects the two common nodes of each design pipe, node_fr is the index of the tail node of the arc that models each design pipe, node_to is the index of the head node of the arc that models each design pipe, and des_pipes is the vector of design pipes that reside along the same arc k.\n\n\n\n\n\nconstraint_des_pipe_head(\n    wm::AbstractNCDModel,\n    n::Int,\n    k::Int,\n    node_fr::Int,\n    node_to::Int,\n    des_pipes::Array{Int,1}\n)\n\nAdds constraints that ensure head difference variables for design pipes along an arc sum to the actual head difference along that single arc. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, k is the index of the arc that connects the two common nodes of each design pipe, node_fr is the index of the tail node of the arc that models each design pipe, node_to is the index of the head node of the arc that models each design pipe, and des_pipes is the vector of design pipes that reside along the same arc k.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_des_pipe_flow","page":"Constraints","title":"WaterModels.constraint_on_off_des_pipe_flow","text":"constraint_on_off_des_pipe_flow(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_des_pipe_flow constraints that limit the amount of flow traveling across a design pipe. Here, wm is the WaterModels object, a is the index of the design pipe, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\nconstraint_on_off_des_pipe_flow(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow along a design pipe based on the construction status of the design pipe (i.e., there is unrestricted flow if the pipe is constructed and zero flow if the pipe is not constructed). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the design pipe, q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction), and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. For AbstractNCModel types, however, these direction-based flow limits are unused.\n\n\n\n\n\nconstraint_on_off_des_pipe_flow(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow along a design pipe based on the construction status of the design pipe (i.e., there is unrestricted flow if the pipe is constructed and zero flow if the pipe is not constructed). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the design pipe, q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction), and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. Note these direction-based limits are currently unused in these constraints.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_des_pipe_head","page":"Constraints","title":"WaterModels.constraint_on_off_des_pipe_head","text":"constraint_on_off_des_pipe_head(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_des_pipe_head constraints that limit the head differences across a design pipe. Here, wm is the WaterModels object, a is the index of the design pipe, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\nconstraint_on_off_des_pipe_head(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int\n)\n\nAdds constraints that limit the (design pipe-specific) head differences across a design pipe based on the construction status of the design pipe (i.e., there is zero head loss across the design pipe if it is not constructed). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the design pipe, node_fr is the index of the tail node of the pipe, and node_to is the index of the head node of the pipe.\n\n\n\n\n\nconstraint_on_off_des_pipe_head(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int\n)\n\nAdds constraints that limit head differences (losses) in the positive (forward) and negative (reverse) directions for a design pipe. Also limits losses based on the construction status of the design pipe, i.e., restricting both losses to zero if a design pipe is not constructed. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, a is the index of the design pipe, node_fr is the index of the tail node of the arc that models the design pipe, and node_to is the index of the head node of the arc that models the design pipe.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_des_pipe_head_loss","page":"Constraints","title":"WaterModels.constraint_on_off_des_pipe_head_loss","text":"constraint_on_off_des_pipe_head_loss(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_des_pipe_head_loss constraints that model the head losses across a design pipe. Here, wm is the WaterModels object, a is the index of the design pipe, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\nconstraint_on_off_des_pipe_head_loss(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdd constraints that model frictional head loss across a design pipe. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the design pipe; node_fr is the index of the tail node of the design pipe; node_to is the index of the head node of the design pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy-Weisbach head loss); L is the length of the design pipe; r is the resistance per unit length of the design pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. For AbstractNCModel types, however, these direction-based flow limits are unused. Note that, when a design pipe is not constructed, flow will be forced to zero by way of constraint_on_off_des_pipe_flow, and head loss, here, will thus be constrained to zero by way of the head loss equation.\n\n\n\n\n\nconstraint_on_off_des_pipe_head_loss(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdd constraints that model frictional head loss across a design pipe. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the design pipe; node_fr is the index of the tail node of the design pipe; node_to is the index of the head node of the design pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy-Weisbach head loss); L is the length of the design pipe; r is the resistance per unit length of the design pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. Note direction-based flow limits are currently unused in these constraints. Also note that, when a design pipe is not constructed, flow will be forced to zero by way of constraint_on_off_des_pipe_flow, and head loss, here, will thus be constrained to zero by way of the head loss equation.\n\n\n\n\n\nconstraint_on_off_des_pipe_head_loss(\n    wm::AbstractLAModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdd constraints that model frictional head loss across a design pipe via a piecewise-linear approximation of the nonlinear, nonconvex head loss relationship. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the design pipe; node_fr is the index of the tail node of the design pipe; node_to is the index of the head node of the design pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy- Weisbach head loss); L is the length of the design pipe; r is the resistance per unit length of the design pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. Note direction-based flow limits are currently unused in these constraints.\n\n\n\n\n\nconstraint_on_off_des_pipe_head_loss(\n    wm::AbstractPWLRDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that model frictional head loss across a design pipe via outer and piecewise-linear inner approximations of the nonlinear, nonconvex head loss relationship. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the design pipe; node_fr is the index of the tail node of the design pipe; node_to is the index of the head node of the design pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy- Weisbach head loss); L is the length of the design pipe; r is the resistance per unit length of the design pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction.\n\n\n\n\n\nconstraint_on_off_des_pipe_head_loss(\n    wm::AbstractLRDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    exponent::Float64,\n    L::Float64,\n    r::Float64,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that model frictional head loss across a design pipe via linear outer approximations of the nonlinear, nonconvex head loss relationship. Here, wm is the WaterModels object; n is the subnetwork (or time) index that is considered; a is the index of the design pipe; node_fr is the index of the tail node of the design pipe; node_to is the index of the head node of the design pipe; exponent is the exponent on flow in the head loss function (i.e., 1.852 for Hazen-Williams head loss and 2.0 for Darcy-Weisbach head loss); L is the length of the design pipe; r is the resistance per unit length of the design pipe; q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction); and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_des_pipe_selection","page":"Constraints","title":"WaterModels.constraint_des_pipe_selection","text":"constraint_des_pipe_selection(\n    wm::AbstractWaterModel,\n    n::Int,\n    k::Int,\n    node_fr::Int,\n    node_to::Int,\n    des_pipes::Array{Int,1}\n)\n\nAdds a constraint that ensures exactly one design pipe will be selected per arc that comprises one or more design pipe possibilities. Here, wm is the WaterModels object, n is the index of a subnetwork within a multinetwork, k is the index of the arc comprising multiple design pipes, node_fr and node_to are node indices that connect the arc, and des_pipes is the vector of design pipes that reside along the same arc k.\n\n\n\n\n\nconstraint_des_pipe_selection(\n    wm::AbstractWaterModel,\n    k::Int,\n    node_fr::Int,\n    node_to::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_des_pipe_selection constraints that enforce the selection of only one design pipe to be constructed along a given arc. Here, wm is the WaterModels object, k is the index of the arc that connects the two common nodes of each design pipe, node_fr is the index of the tail node of the arc that models each design pipe, node_to is the index of the head node of the arc that models each design pipe, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Short-Pipe-Constraints","page":"Constraints","title":"Short Pipe Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"constraint_short_pipe_flow\nconstraint_short_pipe_head","category":"page"},{"location":"constraints.html#WaterModels.constraint_short_pipe_flow","page":"Constraints","title":"WaterModels.constraint_short_pipe_flow","text":"constraint_short_pipe_flow(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_short_pipe_flow constraints that limit the volumetric flow rate across a short pipe. Here, wm is the WaterModels object, a is the index of the short pipe for which flow will be limited, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_short_pipe_flow(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    q_max_reverse::Float64,\n    q_min_forward::Float64,\n)\n\nCurrently does nothing for models of type AbstractNCModel. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the short pipe for which flow will be limited, q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction), and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. For AbstractNCModel types, no constraints will be added, as in these formulation types, flow is not partitioned by direction, and flow bounds are instead imposed during variable instantiation in variable_flow.\n\n\n\n\n\nconstraint_short_pipe_flow(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow along a short pipe based on the direction of flow through the short pipe. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the short pipe for which flow will be limited, q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction), and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_short_pipe_head","page":"Constraints","title":"WaterModels.constraint_short_pipe_head","text":"constraint_short_pipe_head(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_short_pipe_head constraints that limit and establish relationships among head difference and head variables. Here, wm is the WaterModels object, a is the index of the short pipe, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_short_pipe_head(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n)\n\nAdds a constraint that equates the head at the tail node of a short pipe with the head at the head node of the short pipe (i.e., since short pipes have no loss). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the short pipe, node_fr is the index of the tail node of the short pipe, and node_to is the index of the head node of the short pipe.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Pump-Constraints","page":"Constraints","title":"Pump Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"constraint_on_off_pump_flow\nconstraint_on_off_pump_head\nconstraint_on_off_pump_head_gain\nconstraint_on_off_pump_power\nconstraint_on_off_pump_power_best_efficiency\nconstraint_on_off_pump_power_custom\nconstraint_on_off_pump_group\nconstraint_on_off_pump_switch\nconstraint_pump_switch_on\nconstraint_pump_switch_off","category":"page"},{"location":"constraints.html#WaterModels.constraint_on_off_pump_flow","page":"Constraints","title":"WaterModels.constraint_on_off_pump_flow","text":"constraint_on_off_pump_flow(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_pump_flow constraints, which restrict the amount of flow transported through a pump based on its operating status. Here, wm is the WaterModels object, a is the index of the pump, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\nconstraint_on_off_pump_flow(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow across a pump based on the operating status of the pump (i.e., there is unrestricted but bounded flow if the pump is active and zero flow otherwise). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Here, q_min_forward could be interpreted as some minimum amount of flow recommended by the pump manufacturer to avoid pump overheating, or it may be some network- or optimization-based bound (e.g., a flow bound discovered via optimization-based bound tightening).\n\n\n\n\n\nconstraint_on_off_pump_flow(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow across a pump based on the operating status of the pump (i.e., there is unrestricted but bounded flow if the pump is active and zero flow otherwise). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Here, q_min_forward could be interpreted as some minimum amount of flow recommended by the pump manufacturer to avoid pump overheating, or it may be some network- or optimization-based bound (e.g., a flow bound discovered via optimization-based bound tightening).\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_pump_head","page":"Constraints","title":"WaterModels.constraint_on_off_pump_head","text":"constraint_on_off_pump_flow(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_pump_head constraints, which disjunctively limit the head difference between nodes connected by the pump and, if operating, ensures the head difference between nodes is equal to the head gain, constrained by (constraint_on_off_pump_head_gain. Here, wm is the WaterModels object, a is the index of the pump, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\nconstraint_on_off_pump_head(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int\n)\n\nAdds constraints that model head differences at the nodes connected by a pump based on the operating status of the pump (i.e., heads at connecting nodes are decoupled if the pump is inactive, but if the pump is active, the head difference is computed from the pump's head gain, which is a function of flow). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, node_fr is the index of the tail node of the pump, and node_to is the index of the head node of the pump.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_pump_head_gain","page":"Constraints","title":"WaterModels.constraint_on_off_pump_head_gain","text":"constraint_on_off_pump_head_gain(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_pump_head_gain constraints, which, if operating, limit the pump's head gain as a function of flow rate. Here, wm is the WaterModels object, a is the index of the pump, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\nconstraint_on_off_pump_head_gain(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's head gain, if operating, as a possibly nonlinear function of flow rate. If the pump is inactive, the head gain is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, node_fr is the index of the tail node of the pump, node_to is the index of the head node of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Head gain is assumed to be a nonnegative quantity that is directed from node_fr to node_to.\n\n\n\n\n\nconstraint_on_off_pump_head_gain(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's head gain, if operating, as a possibly nonlinear function of flow rate. If the pump is inactive, the head gain is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, node_fr is the index of the tail node of the pump, node_to is the index of the head node of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Head gain is assumed to be a nonnegative quantity that is directed from node_fr to node_to.\n\n\n\n\n\nconstraint_on_off_pump_head_gain(\n    wm::AbstractLAModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's head gain, if operating, as a piecewise- linear approximation of a nonlinear function of flow rate. If the pump is inactive, the head gain is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, node_fr is the index of the tail node of the pump, node_to is the index of the head node of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Head gain is assumed to be nonnegative and is directed from node_fr to node_to.\n\n\n\n\n\nconstraint_on_off_pump_head_gain(\n    wm::AbstractPWLRDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's head gain, if operating, via outer and piecewise-linear inner approximations of the nonlinear function of flow rate. If the pump is inactive, the head gain is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, node_fr is the index of the tail node of the pump, node_to is the index of the head node of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Head gain is assumed to be nonnegative and is directed from node_fr to node_to.\n\n\n\n\n\nconstraint_on_off_pump_head_gain(\n    wm::AbstractLRDModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's head gain, if operating, via linear outer approximations of the nonlinear function of flow rate. If the pump is inactive, the head gain is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, node_fr is the index of the tail node of the pump, node_to is the index of the head node of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Head gain is assumed to be nonnegative and is directed from node_fr to node_to.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_pump_power","page":"Constraints","title":"WaterModels.constraint_on_off_pump_power","text":"constraint_on_off_pump_power(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_pump_power constraints, which, if operating, model the pump's power according to certain assumptions. Here, wm is the WaterModels object, a is the index of the pump, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\nconstraint_on_off_pump_power(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's power consumption, if operating, as a quadratic function of flow rate. If the pump is inactive, the power is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Note that only a quadratic approximation is used for AbstractNCModel.\n\n\n\n\n\nconstraint_on_off_pump_power(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's power consumption, if operating, as a quadratic function of flow rate. If the pump is inactive, the power is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active. Note only a quadratic approximation is used for AbstractNCDModel.\n\n\n\n\n\nconstraint_on_off_pump_power(\n    wm::AbstractLAModel,\n    n::Int,\n    a::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's power consumption, if operating, as a piecewise-linear approximation of a (potentially) nonlinear function of a more accurate model. If the pump is inactive, the power is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active.\n\n\n\n\n\nconstraint_on_off_pump_power(\n    wm::AbstractPWLRDModel,\n    n::Int,\n    a::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that model the pump's power consumption, if operating, as being bounded between piecewise-linear inner and outer approximations of a (potentially) nonlinear function of a more accurate model. If the pump is inactive, the power is restricted to a value of zero. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the pump, and q_min_forward is the minimum (positive) amount of flow when the pump is active.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_pump_power_best_efficiency","page":"Constraints","title":"WaterModels.constraint_on_off_pump_power_best_efficiency","text":"constraint_on_off_pump_power_best_efficiency(\n    wm::AbstractWaterModel,\n    n::Int,\n    a::Int,\n    density::Float64,\n    gravity::Float64,\n    q_min_forward::Float64\n)\n\nAdds a constraint that expresses pump power as a linear expression of flow, where coefficients of this linear expression are computed using an assumption that the pump will be operating at its best efficiency point. Here, wm is the WaterModels object, n is the index of the subnetwork within a multinetwork, a is the index of the pump, density is the density of water, gravity is acceleration due to gravity, and q_min_forward is the minimum amount of flow transported through the pump when it is active (and flow is directed forward).\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_pump_power_custom","page":"Constraints","title":"WaterModels.constraint_on_off_pump_power_custom","text":"constraint_on_off_pump_power_custom(\n    wm::AbstractWaterModel,\n    n::Int,\n    a::Int,\n    power_fixed::Float64,\n    power_variable::Float64\n)\n\nAdds a constraint that expresses pump power as a linear expression of flow, where coefficients of this linear expression are given by power_fixed and power_variable. Here, wm is the WaterModels object, n is the index of the subnetwork within a multinetwork, a is the index of the pump, power_fixed is the amount of power consumed by the pump when it is active and transporting no flow (i.e., the point of intersection at zero flow on the vertical axis of a power-versus-flow curve), and power_variable is the amount of power consumed by the pump per unit flow.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_pump_group","page":"Constraints","title":"WaterModels.constraint_on_off_pump_group","text":"constraint_on_off_pump_group(\n    wm::AbstractWaterModel,\n    n::Int,\n    k::Int,\n    pump_indices::Set{Int}\n)\n\nAdds a constraint that imposes symmetry-breaking lexicographic sorting of pump activation statuses on groups of identical pumps operating in parallel along the same arc of the network. Reduces the combinatorial complexity of problems involving multiple pumps operating in parallel. Here, wm is the WaterModels object, n is the index of the subnetwork within a multinetwork, k is the index of the arc that includes the group of identical pumps, and pump_indices is the set of pump indices for pumps operating in parallel along arc k.\n\n\n\n\n\nconstraint_on_off_pump_power(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_pump_group constraints, which impose symmetry-breaking lexicographic sorting of pump activation statuses on groups of identical pumps operating in parallel along the same arc of the network. Here, wm is the WaterModels object, k is the index of the pump group, and nw is the index of a subnetwork within a multinetwork.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_pump_switch","page":"Constraints","title":"WaterModels.constraint_on_off_pump_switch","text":"constraint_on_off_pump_switch(\n    wm::AbstractWaterModel,\n    a::Int,\n    network_ids::Array{Int,1},\n    max_switches::Int\n)\n\nAdds a constraint that limits the number of times a pump can be switched from off to on in a multiperiod pump scheduling problem. Here, wm is the WaterModels object, a is the index of the pump, network_ids are the network (time) indices used in the summation that limits the number of switches, and max_switches is the number of maximum switches permitted for the pump over the set of network indices.\n\n\n\n\n\nconstraint_on_off_pump_switch(\n    wm::AbstractWaterModel,\n    a::Int;\n    network_ids::Array{Int,1};\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_pump_switch constraint, which limits the number of times a pump can be switched from off to on in a multiperiod pump scheduling problem. Here, wm is the WaterModels object, a is the index of the pump, and network_ids are the network (time) indices used in the summation that limits the number of switches.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_pump_switch_on","page":"Constraints","title":"WaterModels.constraint_pump_switch_on","text":"constraint_pump_switch_on(\n    wm::AbstractWaterModel,\n    a::Int,\n    n_1::Int,\n    n_2::Int,\n    nws_active::Array{Int,1}\n)\n\nAdds a constraint that models the switching of a pump from off to on and constrains its operation, if switched on, to remain on for at least some amount of time. Here, wm is the WaterModels object; a is the index of the pump; n_1 is the first time index modeled by the constraint; n_2 is the adjacent (next) time index modeled by the constraint, which permits limiting the change in pump status (i.e., from off to on); and nws_active are the subnetwork (time) indices where the pump must be constrained to on if the pump is indeed switched from off to on between time indices n_1 and n_2.\n\n\n\n\n\nconstraint_pump_switch_on(\n    wm::AbstractWaterModel,\n    a::Int,\n    n_1::Int,\n    n_2::Int;\n    kwargs...\n)\n\nConstraint template to add constraint_pump_switch_on constraints, which model the switching of a pump from off to on and constrains its operation, if switched on, to remain on for at least some minimum amount of time. Here, wm is the WaterModels object; a is the index of the pump; n_1 is the first time index modeled by the constraint; and n_2 is the adjacent (next) time index modeled by the constraint, which permits limiting the change in pump status (i.e., from off to on).\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_pump_switch_off","page":"Constraints","title":"WaterModels.constraint_pump_switch_off","text":"constraint_pump_switch_off(\n    wm::AbstractWaterModel,\n    a::Int,\n    n_1::Int,\n    n_2::Int,\n    nws_inactive::Array{Int,1}\n)\n\nAdds a constraint that models the switching of a pump from on to off and constrains non-operation, if switched off, to remain off for at least some amount of time. Here, wm is the WaterModels object; a is the index of the pump; n_1 is the first time index modeled by the constraint; n_2 is the adjacent (next) time index modeled by the constraint, which permits limiting the change in pump status (i.e., from on to off); and nws_inactive are the subnetwork (time) indices where the pump must be constrained to off if the pump is indeed switched from on to off between time indices n_1 and n_2.\n\n\n\n\n\nfunction constraint_pump_switch_off(\n    wm::AbstractWaterModel,\n    a::Int,\n    n_1::Int,\n    n_2::Int;\n    kwargs...\n)\n\nConstraint template to add constraint_pump_switch_off constraints, which model the switching of a pump from on to off and constrains non- operation, if switched off, to remain off for at least some minimum amount of time. Here, wm is the WaterModels object; a is the index of the pump; n_1 is the first time index modeled by the constraint; n_2 is the adjacent (next) time index modeled by the constraint, which permits limiting the change in pump status (i.e., from on to off).\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Valve-Constraints","page":"Constraints","title":"Valve Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"constraint_on_off_valve_flow\nconstraint_on_off_valve_head","category":"page"},{"location":"constraints.html#WaterModels.constraint_on_off_valve_flow","page":"Constraints","title":"WaterModels.constraint_on_off_valve_flow","text":"constraint_on_off_valve_flow(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_valve_flow constraints that limit the volumetric flow rate across a valve based on its operating status. Here, wm is the WaterModels object, a is the index of the valve for which flow will be limited, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_on_off_valve_flow(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow along a valve based on the operating status of the valve (i.e., there is bounded flow if the valve is active and zero flow if the valve is inactive). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the valve, q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction), and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction. For AbstractNCModel types, however, these direction-based flow limits are unused.\n\n\n\n\n\nconstraint_on_off_valve_flow(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    q_max_reverse::Float64,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow along a valve based on the operating status of the valve (i.e., there is bounded flow if the valve is active and zero flow if the valve is inactive). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the valve, q_max_reverse is the maximum (negative) amount of flow when flow is traveling in the negative direction (which corresponds to the minimum magnitude of flow when traveling in the negative direction), and q_min_forward is the minimum (positive) amount of flow when flow is traveling in the positive (forward) direction.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_valve_head","page":"Constraints","title":"WaterModels.constraint_on_off_valve_head","text":"constraint_on_off_valve_head(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_valve_head constraints that limit and establish relationships among head variables based on the operating status of the valve. Here, wm is the WaterModels object, a is the index of the valve, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_on_off_valve_head(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int\n)\n\nAdds constraints that model head difference between the nodes connected by a valve based on the operating status of the valve (i.e., heads at connecting nodes are decoupled if the valve is inactive, but if the valve is active, the heads at connecting nodes are equal). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the valve, node_fr is the index of the tail node of the valve, and node_to is the index of the head node of the valve.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#Regulator-Constraints","page":"Constraints","title":"Regulator Constraints","text":"","category":"section"},{"location":"constraints.html","page":"Constraints","title":"Constraints","text":"constraint_on_off_regulator_flow\nconstraint_on_off_regulator_head","category":"page"},{"location":"constraints.html#WaterModels.constraint_on_off_regulator_flow","page":"Constraints","title":"WaterModels.constraint_on_off_regulator_flow","text":"constraint_on_off_regulator_flow(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_regulator_flow constraints that limit the volumetric flow rate across a regulator based on its operating status. Here, wm is the WaterModels object, a is the index of the valve for which flow will be limited, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_on_off_regulator_flow(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow across a regulator based on the operating status of the regulator (i.e., there is unrestricted but bounded flow if the regulator is active and zero flow otherwise). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the regulator, and q_min_forward is the minimum (positive) amount of flow when the regulator is active.\n\n\n\n\n\nconstraint_on_off_regulator_flow(\n    wm::AbstractNCDModel,\n    n::Int,\n    a::Int,\n    q_min_forward::Float64\n)\n\nAdds constraints that limit the amount of flow across a regulator based on the operating status of the regulator (i.e., there is bounded flow if the regulator is active and zero flow otherwise). Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the regulator, and q_min_forward is the minimum (positive) amount of flow when the regulator is active.\n\n\n\n\n\n","category":"function"},{"location":"constraints.html#WaterModels.constraint_on_off_regulator_head","page":"Constraints","title":"WaterModels.constraint_on_off_regulator_head","text":"constraint_on_off_regulator_head(\n    wm::AbstractWaterModel,\n    a::Int;\n    nw::Int=nw_id_default,\n    kwargs...\n)\n\nConstraint template to add constraint_on_off_regulator_head constraints that limit and establish relationships among head variables based on the operating status of the regulator. Here, wm is the WaterModels object, a is the index of the regulator, and nw is the subnetwork (or time) index that is considered.\n\n\n\n\n\nconstraint_on_off_regulator_head(\n    wm::AbstractNCModel,\n    n::Int,\n    a::Int,\n    node_fr::Int,\n    node_to::Int,\n    head_setting::Float64\n)\n\nAdds constraints that model the effects of a pressure-reducing valve (i.e., a regulator). When the regulator is operational (active), the regulator will ensure head at the node indexed by node_to will be equal to head_setting. When the regulator is inactive, heads at connecting nodes are decoupled. Here, wm is the WaterModels object, n is the subnetwork (or time) index that is considered, a is the index of the regulator, node_fr is the index of the tail node of the regulator, node_to is the index of the head node of the regulator, and head_setting is the value of head to be set (if the regulator is active) at the (thus downstream) node indexed by node_to.\n\n\n\n\n\n","category":"function"},{"location":"specifications.html#Problem-Specifications","page":"Problem Specifications","title":"Problem Specifications","text":"","category":"section"},{"location":"specifications.html#Water-Flow-(WF)","page":"Problem Specifications","title":"Water Flow (WF)","text":"","category":"section"},{"location":"specifications.html#Functions","page":"Problem Specifications","title":"Functions","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Create head loss functions, if necessary.\n_function_head_loss(wm)","category":"page"},{"location":"specifications.html#Objective","page":"Problem Specifications","title":"Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"objective_wf(wm)","category":"page"},{"location":"specifications.html#Variables","page":"Problem Specifications","title":"Variables","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Create head loss functions, if necessary.\nvariable_head(wm)\nvariable_flow(wm)\nvariable_pump_head_gain(wm)\nvariable_pump_power(wm)\n\n# Indicator (status) variables.\nvariable_des_pipe_indicator(wm)\nvariable_pump_indicator(wm)\nvariable_regulator_indicator(wm)\nvariable_valve_indicator(wm)\n\n# Create flow-related variables for node attachments.\nvariable_demand_flow(wm)\nvariable_reservoir_flow(wm)\nvariable_tank_flow(wm)","category":"page"},{"location":"specifications.html#Constraints","page":"Problem Specifications","title":"Constraints","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Flow conservation at all nodes.\nfor (i, node) in ref(wm, :node)\n    constraint_flow_conservation(wm, i)\n    constraint_node_directionality(wm, i)\nend\n\n# Constraints on pipe flows, heads, and physics.\nfor (a, pipe) in ref(wm, :pipe)\n    constraint_pipe_head(wm, a)\n    constraint_pipe_head_loss(wm, a)\n    constraint_pipe_flow(wm, a)\nend\n\n# Selection of design pipes along unique arcs.\nfor (k, arc) in ref(wm, :des_pipe_arc)\n    constraint_des_pipe_flow(wm, k, arc[1], arc[2])\n    constraint_des_pipe_head(wm, k, arc[1], arc[2])\n    constraint_des_pipe_selection(wm, k, arc[1], arc[2])\nend\n\n# Constraints on design pipe flows, heads, and physics.\nfor (a, des_pipe) in ref(wm, :des_pipe)\n    constraint_on_off_des_pipe_head(wm, a)\n    constraint_on_off_des_pipe_head_loss(wm, a)\n    constraint_on_off_des_pipe_flow(wm, a)\nend\n\n# Constraints on pump flows, heads, and physics.\nfor (a, pump) in ref(wm, :pump)\n    constraint_on_off_pump_head(wm, a)\n    constraint_on_off_pump_head_gain(wm, a)\n    constraint_on_off_pump_flow(wm, a)\n    constraint_on_off_pump_power(wm, a)\nend\n\nfor (k, pump_group) in ref(wm, :pump_group)\n    constraint_on_off_pump_group(wm, k)\nend\n\n# Constraints on short pipe flows and heads.\nfor (a, regulator) in ref(wm, :regulator)\n    constraint_on_off_regulator_head(wm, a)\n    constraint_on_off_regulator_flow(wm, a)\nend\n\n# Constraints on short pipe flows and heads.\nfor (a, short_pipe) in ref(wm, :short_pipe)\n    constraint_short_pipe_head(wm, a)\n    constraint_short_pipe_flow(wm, a)\nend\n\n# Constraints on tank volumes.\nfor (i, tank) in ref(wm, :tank)\n    # Set the initial tank volume.\n    constraint_tank_volume(wm, i)\nend\n\n# Constraints on valve flows and heads.\nfor (a, valve) in ref(wm, :valve)\n    constraint_on_off_valve_head(wm, a)\n    constraint_on_off_valve_flow(wm, a)\nend","category":"page"},{"location":"specifications.html#Multinetwork-Water-Flow-(MN-WF)","page":"Problem Specifications","title":"Multinetwork Water Flow (MN WF)","text":"","category":"section"},{"location":"specifications.html#Functions-2","page":"Problem Specifications","title":"Functions","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Create head loss functions, if necessary.\n_function_head_loss(wm)","category":"page"},{"location":"specifications.html#Objective-2","page":"Problem Specifications","title":"Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"objective_wf(wm)","category":"page"},{"location":"specifications.html#Variables-2","page":"Problem Specifications","title":"Variables","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Get all network IDs in the multinetwork.\nnetwork_ids = sort(collect(nw_ids(wm)))\nnetwork_ids_inner = length(network_ids) > 1 ? network_ids[1:end-1] : network_ids\n\nfor n in network_ids_inner\n    # Physical variables.\n    variable_head(wm; nw=n)\n    variable_flow(wm; nw=n)\n    variable_pump_head_gain(wm; nw=n)\n    variable_pump_power(wm; nw=n)\n\n    # Indicator (status) variables.\n    variable_des_pipe_indicator(wm; nw=n)\n    variable_pump_indicator(wm; nw=n)\n    variable_regulator_indicator(wm; nw=n)\n    variable_valve_indicator(wm; nw=n)\n\n    # Create flow-related variables for node attachments.\n    variable_demand_flow(wm; nw=n)\n    variable_reservoir_flow(wm; nw=n)\n    variable_tank_flow(wm; nw=n)\nend\n\nif length(network_ids) > 1\n    variable_head(wm; nw = network_ids[end])\nend","category":"page"},{"location":"specifications.html#Constraints-2","page":"Problem Specifications","title":"Constraints","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Get all network IDs in the multinetwork.\nnetwork_ids = sort(collect(nw_ids(wm)))\nnetwork_ids_inner = length(network_ids) > 1 ? network_ids[1:end-1] : network_ids\n\nfor n in network_ids_inner\n    # Flow conservation at all nodes.\n    for i in ids(wm, :node; nw=n)\n        constraint_flow_conservation(wm, i; nw=n)\n        constraint_node_directionality(wm, i; nw=n)\n    end\n\n    # Constraints on pipe flows, heads, and physics.\n    for a in ids(wm, :pipe; nw=n)\n        constraint_pipe_flow(wm, a; nw=n)\n        constraint_pipe_head(wm, a; nw=n)\n        constraint_pipe_head_loss(wm, a; nw=n)\n    end\n\n    # Constraints on pump flows, heads, and physics.\n    for a in ids(wm, :pump; nw=n)\n        constraint_on_off_pump_head(wm, a; nw=n)\n        constraint_on_off_pump_head_gain(wm, a; nw=n)\n        constraint_on_off_pump_flow(wm, a; nw=n)\n        constraint_on_off_pump_power(wm, a; nw=n)\n    end\n\n    # Constraints on groups of parallel pumps.\n    for k in ids(wm, :pump_group; nw=n)\n        constraint_on_off_pump_group(wm, k; nw=n)\n    end\n\n    # Constraints on short pipe flows and heads.\n    for a in ids(wm, :regulator; nw=n)\n        constraint_on_off_regulator_head(wm, a; nw=n)\n        constraint_on_off_regulator_flow(wm, a; nw=n)\n    end\n\n    # Constraints on short pipe flows and heads.\n    for a in ids(wm, :short_pipe; nw=n)\n        constraint_short_pipe_head(wm, a; nw=n)\n        constraint_short_pipe_flow(wm, a; nw=n)\n    end\n\n    # Constraints on valve flows and heads.\n    for a in ids(wm, :valve; nw=n)\n        constraint_on_off_valve_head(wm, a; nw=n)\n        constraint_on_off_valve_flow(wm, a; nw=n)\n    end\nend\n\n# Start with the first network, representing the initial time step.\nn_1 = network_ids[1]\n\n# Constraints on tank volumes.\nfor i in ids(wm, :tank; nw = n_1)\n    # Set initial conditions of tanks.\n    constraint_tank_volume(wm, i; nw = n_1)\nend\n\nif length(network_ids) > 1\n    # Constraints on tank volumes.\n    for n_2 in network_ids[2:end]\n        # Constrain tank volumes after the initial time index.\n        for i in ids(wm, :tank; nw = n_2)\n            constraint_tank_volume(wm, i, n_1, n_2)\n        end\n\n        # Update the first network used for integration.\n        n_1 = n_2\n    end\nend","category":"page"},{"location":"specifications.html#Multinetwork-Water-Flow-with-Switching-Constraints-(MN-WF-SWITCHING)","page":"Problem Specifications","title":"Multinetwork Water Flow with Switching Constraints (MN WF SWITCHING)","text":"","category":"section"},{"location":"specifications.html#Inherited-Functions,-Variables,-Constraints,-and-Objective","page":"Problem Specifications","title":"Inherited Functions, Variables, Constraints, and Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Build the base multinetwork problem.\nbuild_mn_wf(wm)","category":"page"},{"location":"specifications.html#Variables-3","page":"Problem Specifications","title":"Variables","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Get all network IDs in the multinetwork.\nnetwork_ids = sort(collect(nw_ids(wm)))\n\n# Get the first network ID in the multinetwork.\nn_1 = network_ids[1]\n\nfor n_2 in network_ids[2:end-1]\n    # Add pump switching variables.\n    variable_pump_switch_on(wm; nw = n_2)\n    variable_pump_switch_off(wm; nw = n_2)\n\n    n_1 = n_2\nend","category":"page"},{"location":"specifications.html#Constraints-3","page":"Problem Specifications","title":"Constraints","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Get all network IDs in the multinetwork.\nnetwork_ids = sort(collect(nw_ids(wm)))\n\n# Get the first network ID in the multinetwork.\nn_1 = network_ids[1]\n\nfor n_2 in network_ids[2:end-1]\n    for a in ids(wm, :pump, nw = n_2)\n        # Add constraints that define switching variables.\n        constraint_pump_switch_on(wm, a, n_1, n_2)\n        constraint_pump_switch_off(wm, a, n_1, n_2)\n    end\n\n    n_1 = n_2\nend\n\nfor a in ids(wm, :pump; nw = network_ids[1])\n    # Add constraints on the total number of pump switches.\n    constraint_on_off_pump_switch(wm, a, network_ids[2:end-1])\nend","category":"page"},{"location":"specifications.html#Optimal-Water-Flow-(OWF)","page":"Problem Specifications","title":"Optimal Water Flow (OWF)","text":"","category":"section"},{"location":"specifications.html#Inherited-Functions,-Variables,-Constraints,-and-Objective-2","page":"Problem Specifications","title":"Inherited Functions, Variables, Constraints, and Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Build the water flow problem.\nbuild_wf(wm)","category":"page"},{"location":"specifications.html#Objective-3","page":"Problem Specifications","title":"Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Add the optimal water flow objective.\nobjective_owf(wm)","category":"page"},{"location":"specifications.html#Multinetwork-Optimal-Water-Flow-(MN-OWF)","page":"Problem Specifications","title":"Multinetwork Optimal Water Flow (MN OWF)","text":"","category":"section"},{"location":"specifications.html#Inherited-Functions,-Variables,-Constraints,-and-Objective-3","page":"Problem Specifications","title":"Inherited Functions, Variables, Constraints, and Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Build the water flow problem.\nbuild_mn_wf(wm)","category":"page"},{"location":"specifications.html#Objective-4","page":"Problem Specifications","title":"Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Add the optimal water flow objective.\nobjective_owf(wm)","category":"page"},{"location":"specifications.html#Constraints-4","page":"Problem Specifications","title":"Constraints","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Get all network IDs in the multinetwork.\nnetwork_ids = sort(collect(nw_ids(wm)))\n\n# Ensure tanks recover their initial volume.\nn_1, n_f = network_ids[1], network_ids[end]\n\nfor i in ids(wm, n_f, :tank)\n    constraint_tank_volume_recovery(wm, i, n_1, n_f)\nend","category":"page"},{"location":"specifications.html#Optimal-Design-(DES)","page":"Problem Specifications","title":"Optimal Design (DES)","text":"","category":"section"},{"location":"specifications.html#Inherited-Functions,-Variables,-Constraints,-and-Objective-4","page":"Problem Specifications","title":"Inherited Functions, Variables, Constraints, and Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Build the water flow problem.\nbuild_wf(wm)","category":"page"},{"location":"specifications.html#Objective-5","page":"Problem Specifications","title":"Objective","text":"","category":"section"},{"location":"specifications.html","page":"Problem Specifications","title":"Problem Specifications","text":"# Add the network design objective.\nobjective_des(wm)","category":"page"},{"location":"result-data.html#WaterModels-Result-Data-Format","page":"Result Data Format","title":"WaterModels Result Data Format","text":"","category":"section"},{"location":"result-data.html#The-Result-Data-Dictionary","page":"Result Data Format","title":"The Result Data Dictionary","text":"","category":"section"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"WaterModels uses a dictionary to organize the results of a solve_ command. The dictionary uses strings as key values so it can be serialized to JSON for algorithmic data exchange. The data dictionary organization is designed to be consistent with The Network Data Dictionary.","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"At the top level, the results data dictionary is structured as follows:","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"{\n    \"optimizer\": <string>,        # name of the solver used to solve the model\n    \"termination_status\": <type>, # optimizer status at termination\n    \"dual_status\": <type>,        # optimizer dual status at termination\n    \"primal_status\": <type>,      # optimizer primal status at termination\n    \"solve_time\": <float>,        # reported solve time (in seconds)\n    \"objective\": <float>,         # the final evaluation of the objective function\n    \"objective_lb\": <float>,      # the final lower bound of the objective function (if available)\n    \"solution\": {...}             # complete solution information (details below)\n}","category":"page"},{"location":"result-data.html#Solution-Data","page":"Result Data Format","title":"Solution Data","text":"","category":"section"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"The \"solution\" subdictionary provides detailed information about the problem solution produced by the solve_ command. The solution is organized similarly to The Network Data Dictionary with the same nested structure and parameter names, when available. For example, for a single-network problem, result[\"solution\"][\"pipe\"][\"1\"] reports all the solution values associated with the pipe at index \"1\", e.g.,","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"{\n    \"qn\": 0.0,\n    \"qp\": 2.0,\n    \"dhn\": 0.0,\n    \"q\": 2.0,\n    \"dhp\": 0.033770,\n    \"y\": 1.0\n}","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"Similarly, for a multinetwork problem, as an example, result[\"nw\"][\"3\"][\"pump\"][\"2\"] reports the solution values associated with the pump at pump index \"2\" and time index \"3\", e.g.,","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"{\n    \"qn\": 0.0,\n    \"c\": 0.16850289352749692,\n    \"g\": 0.8372647243015188,\n    \"P\": 0.00016374541106904265,\n    \"status\": 1.0,\n    \"qp\": 0.36694422549881334,\n    \"q\": 0.36694422549881334,\n    \"E\": 1.8023959936938814e-6,\n    \"y\": 1.0\n}","category":"page"},{"location":"result-data.html#Solution-Data-Schema","page":"Result Data Format","title":"Solution Data Schema","text":"","category":"section"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"By default, all solution data are reported in per-unit (non-dimensionalized) units. Below are common outputs of the implemented optimization models, which are sometimes based on flow directionality:","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"{\n    \"multiinfrastructure\": <bool>  # Whether or not the solution data is part of a broader multi-infrastructure solution.\n    \"multinetwork\": <bool>         # Whether or not the network data describes a multinetwork (e.g., a time series of networks).\n    \"per_unit\": <bool>,            # Whether the data is in per-unit (non-dimensionalized) or SI units.\n    \"base_flow\": <float>,          # Base for non-dimensionalizing volumetric flow rate. SI units are cubic meters per second.\n    \"base_head\": <float>,          # Base for non-dimensionalizing total hydraulic head head. SI units are meters.\n    \"base_length\": <float>,        # Base for non-dimensionalizing length. SI units are meters.\n    \"base_mass\": <float>,          # Base for non-dimensionalizing mass. SI units are kilograms.\n    \"base_time\": <float>,          # Base for non-dimensionalizing time. SI units are seconds.\n    \"node\": {\n        \"1\": {\n            \"h\": <float>,  # Total hydraulic head of the node. SI units are meters.\n            \"p\": <float>   # Pressure head of the node. SI units are meters.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"demand\": {\n        \"1\": {\n            \"q\": <float>  # Demanded volumetric flow rate at the demand point. SI units are cubic meters per second.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"reservoir\": {\n        \"1\": {\n            \"q\": <float>  # Outgoing volumetric flow rate from the reservoir. SI units are cubic meters per second.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"tank\": {\n        \"1\": {\n            \"V\": <float>, # Volume of water contained by the tank. SI units are cubic meters.\n            \"q\": <float>  # Outgoing volumetric flow rate from the reservoir. SI units are cubic meters per second.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"pipe\": {\n        \"1\": {\n            \"q\": <float>,    # Volumetric flow rate transported through the pipe. SI units are cubic meters per second.\n            \"qp\": <float>,   # Volumetric flow rate transported in the positive direction. SI units are cubic meters per second.\n            \"qn\": <float>,   # Volumetric flow rate transported in the negative direction. SI units are cubic meters per second.\n            \"dhp\": <float>,  # Total hydraulic head decrease in the positive direction of flow. SI units are meters.\n            \"dhn\": <float>,  # Total hydraulic head decrease in the negative direction of flow. SI units are meters.\n            \"y\": <float>     # Flow direction, i.e., one if flow is transported _from_ \"node_fr\" and zero otherwise.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"des_pipe\": {\n        \"1\": {\n            \"q\": <float>,      # Volumetric flow rate transported through the design pipe. SI units are cubic meters per second.\n            \"qp\": <float>,     # Volumetric flow rate transported in the positive direction. SI units are cubic meters per second.\n            \"qn\": <float>,     # Volumetric flow rate transported in the negative direction. SI units are cubic meters per second.\n            \"dhp\": <float>,    # Total hydraulic head decrease in the positive direction of flow. SI units are meters.\n            \"dhn\": <float>,    # Total hydraulic head decrease in the negative direction of flow. SI units are meters.\n            \"y\": <float>,      # Flow direction, i.e., one if flow is transported _from_ \"node_fr\" and zero otherwise.\n            \"status\": <float>  # Pipe construction status, i.e., one if the pipe is constructed and zero otherwise.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"short_pipe\": {\n        \"1\": {\n            \"q\": <float>,   # Volumetric flow rate transported through the short pipe. SI units are cubic meters per second.\n            \"qp\": <float>,  # Volumetric flow rate transported in the positive direction. SI units are cubic meters per second.\n            \"qn\": <float>,  # Volumetric flow rate transported in the negative direction. SI units are cubic meters per second.\n            \"y\": <float>    # Flow direction, i.e., one if flow is transported _from_ \"node_fr\" and zero otherwise.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"pump\": {\n        \"1\": {\n            \"q\": <float>,      # Volumetric flow rate transported through the pump. SI units are cubic meters per second.\n            \"qp\": <float>,     # Volumetric flow rate transported in the positive direction. SI units are cubic meters per second.\n            \"qn\": <float>,     # Volumetric flow rate transported in the negative direction. SI units are cubic meters per second.\n            \"y\": <float>,      # Flow direction, i.e., one if flow is transported _from_ \"node_fr\" and zero otherwise.\n            \"g\": <float>,      # Head gain (increase) from \"node_fr\" to \"node_to\" resulting from the pump. SI units are meters.\n            \"c\": <float>,      # Cost of operating the pump over the time index (step) of interest. Standard units are currency.\n            \"P\": <float>,      # Power consumed by the pump over the time index (step) of interest. SI units are Watts.\n            \"E\": <float>,      # Energy consumption of the pump over the time index (step) of interest. SI units are Joules.\n            \"status\": <float>  # Status of the pump, i.e., one if the pump is active and zero otherwise.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"valve\": {\n        \"1\": {\n            \"q\": <float>,      # Volumetric flow rate transported through the valve. SI units are cubic meters per second.\n            \"qp\": <float>,     # Volumetric flow rate transported in the positive direction. SI units are cubic meters per second.\n            \"qn\": <float>,     # Volumetric flow rate transported in the negative direction. SI units are cubic meters per second.\n            \"y\": <float>       # Flow direction, i.e., one if flow is transported _from_ \"node_fr\" and zero otherwise.\n            \"status\": <float>  # Status of the valve, i.e., one if the valve is opened and zero otherwise.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    },\n    \"regulator\": {\n        \"1\": {\n            \"q\": <float>,      # Volumetric flow rate transported through the regulator. SI units are cubic meters per second.\n            \"qp\": <float>,     # Volumetric flow rate transported in the positive direction. SI units are cubic meters per second.\n            \"qn\": <float>,     # Volumetric flow rate transported in the negative direction. SI units are cubic meters per second.\n            \"y\": <float>       # Flow direction, i.e., one if flow is transported _from_ \"node_fr\" and zero otherwise.\n            \"status\": <float>  # Status of the regulator, i.e., one if the regulator is active and zero otherwise.\n        },\n        \"2\": {\n            ...\n        },\n        ...\n    }\n}","category":"page"},{"location":"result-data.html#Transforming-Solution-Data","page":"Result Data Format","title":"Transforming Solution Data","text":"","category":"section"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"Because the data dictionary and the solution dictionary have the same structure, the InfrastructureModels update_data! helper function can be used to update a data dictionary with values from a solution, e.g.,","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"import InfrastructureModels\n\nInfrastructureModels.update_data!(\n  data[\"nw\"][\"3\"][\"pump\"][\"1\"],\n  result[\"solution\"][\"nw\"][\"3\"][\"pump\"][\"1\"]\n)","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"Note that, by default, all results are reported in a per-unit (non-dimensionalized) system. Additional data from WaterModels can be used to convert such data back to their dimensionalized forms. For example, the code block below translates a per-unit pump flow rate to SI units, then the more conventional units of liters per second.","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"# Get a pump volumetric flow rate solution in the per-unit system.\nflow_per_unit = result[\"solution\"][\"nw\"][\"3\"][\"pump\"][\"1\"][\"q\"]\n\n# Get the per-unit scalar used to convert back to SI units.\nbase_flow = data[\"base_flow\"]\n\n# Compute the volumetric flow rate in SI units (cubic meters per second).\nbase_flow * flow_per_unit\n\n# Compute the volumetric flow rate in liters per second.\nbase_flow * flow_per_unit * 1000.0","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"Note also that per-unit base quantities are also reported in the solution data dictionary for convenience, e.g.,","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"# Should return `true`.\nresult[\"solution\"][\"base_flow\"] == data[\"base_flow\"]","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"For convenience, solution data can be transformed to SI units using","category":"page"},{"location":"result-data.html","page":"Result Data Format","title":"Result Data Format","text":"make_si_units!(result[\"solution\"])","category":"page"},{"location":"formulations.html#Network-Formulations","page":"Network Formulations","title":"Network Formulations","text":"","category":"section"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"CurrentModule = WaterModels","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"All methods for constructing WaterModels are ultimately derived from the following type:","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"AbstractWaterModel","category":"page"},{"location":"formulations.html#WaterModels.AbstractWaterModel","page":"Network Formulations","title":"WaterModels.AbstractWaterModel","text":"Root of the water formulation type hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"formulations.html#Type-Hierarchy","page":"Network Formulations","title":"Type Hierarchy","text":"","category":"section"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"We begin with the top of the modeling hierarchy, where we can distinguish among approximations and relaxations for the the physics of water flow. There are currently six formulations supported in WaterModels. Specifically, there are two exact nonconvex formulations, one approximation, and three relaxations:","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"# Exact formulations.\nabstract type AbstractNCModel <: AbstractWaterModel end\nabstract type AbstractNCDModel <: AbstractNCModel end\n\n# Approximation-based formulations.\nabstract type AbstractLAModel <: AbstractNCModel end\n\n# Relaxation-based formulations.\nabstract type AbstractCRDModel <: AbstractNCDModel end\nabstract type AbstractLRDModel <: AbstractCRDModel end\nabstract type AbstractPWLRDModel <: AbstractCRDModel end","category":"page"},{"location":"formulations.html#Water-Models","page":"Network Formulations","title":"Water Models","text":"","category":"section"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"Each of the abstract modeling types are used to derive a more specific WaterModel type:","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"mutable struct NCWaterModel <: AbstractNCModel @wm_fields end\nmutable struct NCDWaterModel <: AbstractNCDModel @wm_fields end\nmutable struct LAWaterModel <: AbstractLAModel @wm_fields end\nmutable struct CRDWaterModel <: AbstractCRDModel @wm_fields end\nmutable struct LRDWaterModel <: AbstractLRDModel @wm_fields end\nmutable struct PWLRDWaterModel <: AbstractPWLRDModel @wm_fields end","category":"page"},{"location":"formulations.html#User-Defined-Abstractions","page":"Network Formulations","title":"User-Defined Abstractions","text":"","category":"section"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"User-defined abstractions can begin from a root abstract model like AbstractWaterModel, e.g.,","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"abstract type AbstractFooModel <: AbstractWaterModel end\nmutable struct FooWaterModel <: AbstractFooModel @wm_fields end","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"They can also be derived from existing modeling types, e.g.,","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"abstract type AbstractSpecialWaterModel <: AbstractPWLRDModel end\nmutable struct SpecialWaterModel <: AbstractSpecialWaterModel @wm_fields end","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"As an example, the above might be used to define some specialized piecewise-linear, direction-based water flow relaxation. This definition of new types (AbstractSpecialWaterModel and SpecialWaterModel) would allow the developer to reuse common variables, constraints, and objectives already defined over AbstractPWLRDModel while also potentially overriding other variables, constraints, and objectives. This overriding is accomplished by implementing new but equivalently-named model-building functions that are defined over AbstractSpecialWaterModel instead of AbstractPWLRDModel (or its ancestors, i.e., AbstractCRDModel, AbstractNCDModel, and AbstractWaterModel).","category":"page"},{"location":"formulations.html#Supported-Formulations","page":"Network Formulations","title":"Supported Formulations","text":"","category":"section"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"All formulation names refer to how the underlying physics of a water network are modeled. For example, the LRD model uses a linear relaxation (LR), direction-based (D) model of water network physics.","category":"page"},{"location":"formulations.html","page":"Network Formulations","title":"Network Formulations","text":"Formulation Description\nNC Physics modeled using nonlinear equations.\nNCD Physics modeled using nonlinear equations. Flow direction modeled using binary variables.\nLA Physics modeled using piecewise-linear approximations.\nCRD Physics modeled using convex relaxations. Flow direction modeled using binary variables.\nLRD Physics modeled using linear relaxations. Flow direction modeled using binary variables.\nPWLRD Physics modeled using piecewise relaxations. Flow direction modeled using binary variables.","category":"page"},{"location":"variables.html#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables.html","page":"Variables","title":"Variables","text":"The following methods provide a compositional approach for defining common variables used in water network optimization models.","category":"page"},{"location":"variables.html#Formulation-agnostic-Variables","page":"Variables","title":"Formulation-agnostic Variables","text":"","category":"section"},{"location":"variables.html","page":"Variables","title":"Variables","text":"These methods are always defined over AbstractWaterModel.","category":"page"},{"location":"variables.html#Nodal-Variables","page":"Variables","title":"Nodal Variables","text":"","category":"section"},{"location":"variables.html","page":"Variables","title":"Variables","text":"variable_head\nvariable_demand_flow\nvariable_reservoir_flow\nvariable_tank_flow","category":"page"},{"location":"variables.html#WaterModels.variable_head","page":"Variables","title":"WaterModels.variable_head","text":"variable_head(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nInstantiates bounded (by default) or unbounded total hydraulic head (or head) variables for nodes in the network at subnetwork (or time) index nw, i.e., h[i] for i in node. Also instantiates JuMP expressions that are affine expressions of each head, i.e., pressure, which is computed as p[i] = h[i] - elevation[i], and tank volume (at each tank attached to a node), which is computed as V[k] = 0.25 * pi * diameter[k]^2 * (h[i] - elevation[i]), where k is the index of the tank; diameter[k] is the cross-sectional diameter of the (cylindrical) tank; and i is the index of the node to which the tank is attached.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_demand_flow","page":"Variables","title":"WaterModels.variable_demand_flow","text":"variable_demand_flow(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates unbounded volumetric flow rate demand variables for all dispatchable demands in the network at subnetwork (or time) index nw, i.e., q_demand[i] for i in dispatchable_demand.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_reservoir_flow","page":"Variables","title":"WaterModels.variable_reservoir_flow","text":"variable_reservoir_flow(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates bounded (by default) or unbounded outgoing volumetric flow rate variables for reservoirs in the network at subnetwork (or time) index nw, i.e., q_reservoir[i] for i in reservoir. Note that these variables are always nonnegative, since for each reservoir, there will never be incoming flow.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_tank_flow","page":"Variables","title":"WaterModels.variable_tank_flow","text":"variable_tank_flow(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates bounded (by default) or unbounded volumetric flow rate variables for tanks in the network at subnetwork (or time) index nw, i.e., q_tank[i] for i in tank. Note that, unlike reservoirs, tanks can have inflow, represented as a negative quantity.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#Link-Variables","page":"Variables","title":"Link Variables","text":"","category":"section"},{"location":"variables.html","page":"Variables","title":"Variables","text":"variable_des_pipe_indicator\nvariable_pump_head_gain\nvariable_pump_power\nvariable_pump_indicator\nvariable_pump_switch_off\nvariable_pump_switch_on\nvariable_regulator_indicator\nvariable_valve_indicator","category":"page"},{"location":"variables.html#WaterModels.variable_des_pipe_indicator","page":"Variables","title":"WaterModels.variable_des_pipe_indicator","text":"variable_des_pipe_indicator(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    report::Bool=true\n)\n\nCreates binary variables for design pipes in the network at subnetwork (or time) index nw, i.e., z_des_pipe[a] for a in des_pipe, where one denotes that the pipe has been selected within the design at the current subnetwork (or time) index, and zero indicates that the design pipe has had not been selected.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_pump_head_gain","page":"Variables","title":"WaterModels.variable_pump_head_gain","text":"variable_pump_head_gain(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates bounded (by default) or unbounded head gain variables for pumps in in the network at subnetwork (or time) index nw, i.e., g_pump[a] for a in pump. Note that these variables are always nonnegative, since for each pump, there will never be negative head gain (i.e., pumps only increase head). Head gain is always directed from \"nodefr\" (i.e., the tail node of the arc) to \"nodeto\" (i.e., the head node of the arc).\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_pump_power","page":"Variables","title":"WaterModels.variable_pump_power","text":"variable_pump_power(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates bounded (by default) or unbounded power consumption variables for pumps in the network at subnetwork (or time) index nw, i.e., P[a] for a in pump. Note that these variables are always nonnegative since each pump only consumes power. Additionally, two sets of JuMP expressions are also derived from these power variables: energy consumption, i.e., E[a] for a in pump and cost of pump operation across a time step, i.e., c[a] for a in pump.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_pump_indicator","page":"Variables","title":"WaterModels.variable_pump_indicator","text":"variable_pump_indicator(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    report::Bool=true\n)\n\nCreates binary variables for pumps in the network at subnetwork (or time) index nw, i.e., z_pump[a] for a in pump, where one denotes that the pump is currently operating (i.e., on), and zero indicates that the pump is not operating (i.e., off).\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_pump_switch_off","page":"Variables","title":"WaterModels.variable_pump_switch_off","text":"variable_pump_switch_off(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    report::Bool=true\n)\n\nCreates binary variables for pumps in the network at subnetwork (or time) index nw, i.e., z_switch_off_pump[a] for a in pump, where one denotes that the pump has been switched to the \"off\" status at the current subnetwork (or time) index, and zero indicates that the pump has had no status change.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_pump_switch_on","page":"Variables","title":"WaterModels.variable_pump_switch_on","text":"variable_pump_switch_on(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    report::Bool=true\n)\n\nCreates binary variables for pumps in the network at subnetwork (or time) index nw, i.e., z_switch_on_pump[a] for a in pump, where one denotes that the pump has been switched to the \"on\" status at the current subnetwork (or time) index, and zero indicates that the pump has had no status change.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_regulator_indicator","page":"Variables","title":"WaterModels.variable_regulator_indicator","text":"variable_regulator_indicator(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    report::Bool=true\n)\n\nCreates binary variables for regulators in the network at subnetwork (or time) index nw, i.e., z_regulator[a] for a in regulator, where one denotes that the pressure reducing regulator is currently active and zero otherwise.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#WaterModels.variable_valve_indicator","page":"Variables","title":"WaterModels.variable_valve_indicator","text":"variable_valve_indicator(\n    wm::AbstractWaterModel;\n    nw::Int=nw_id_default,\n    relax::Bool=false,\n    report::Bool=true\n)\n\nCreates binary variables for valves in the network at subnetwork (or time) index nw, i.e., z_valve[a] for a in valve. Here, one denotes that the valve is open and zero denotes that the valve is closed.\n\n\n\n\n\n","category":"function"},{"location":"variables.html#Flow-related-Variables","page":"Variables","title":"Flow-related Variables","text":"","category":"section"},{"location":"variables.html","page":"Variables","title":"Variables","text":"In most of the implemented formulations, we model flow-related quantities in different ways. The formulation-specific functions used for instantiating the associated variables are described below.","category":"page"},{"location":"variables.html","page":"Variables","title":"Variables","text":"variable_flow","category":"page"},{"location":"variables.html#WaterModels.variable_flow","page":"Variables","title":"WaterModels.variable_flow","text":"variable_flow(\n    wm::AbstractNCModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates bounded (by default) or unbounded flow variables for all node- connecting components (e.g., pipes, pumps) in the network at subnetwork (or time) index nw, e.g., q_pipe[a] for a in pipe, q_pump[a] for a in pump. Used for non-flow-direction-based network model formulations only.\n\n\n\n\n\nvariable_flow(\n    wm::AbstractNCDModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates bounded (by default) or unbounded direction-based flow variables for all node-connecting components (e.g., pipes, pumps) in the network at subnetwork (or time) index nw, e.g., qp_pipe[a] and qn_pipe[a] for a in pipe (i.e., positively-directed and negatively-directed flow through the pipe). Also creates JuMP expressions for direction-valued flow, e.g., q_pipe[a] = qp_pipe[a] - qn_pipe[a] for a in pipe. Also creates binary flow direction variables, e.g., y_pipe[a] for a in pipe, where one indicates flow traveling from node_fr (tail of the arc) to node_to (head of the arc). Also creates direction-based head difference variables for pipes and design pipes in the network, e.g., dhp_pipe[a] and dhn_pipe[a] for a in pipe. Used for flow direction-based network model formulations only.\n\n\n\n\n\nvariable_flow(\n    wm::AbstractLAModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates flow-related variables related to linear approximation- (LA-) based optimization models. First, creates flow variables for all node-connecting components (e.g., pipes) in the network at subnetwork (or time) index nw, e.g., q_pipe[a] for a in pipe. Then, creates continuous convex combination variables used to construct necessary linear approximations, e.g., lambda_pipe[a] for a in pipe, where each is bounded between zero and one. Finally, creates binary convex combination variables used for piecewise-linear modeling of the approximating constraints, e.g., x_pipe[a] for a in pipe.\n\n\n\n\n\nvariable_flow(\n    wm::AbstractPWLRDModel;\n    nw::Int=nw_id_default,\n    bounded::Bool=true,\n    report::Bool=true\n)\n\nCreates flow-related variables linked to piecewise-linear, relaxation- and direction- (PWLRD-) based optimization models. First, creates direction-based flow variables for all node-connecting components (e.g., pipes) in the network at subnetwork (or time) index nw, e.g., qp_pipe[a] and qn_pipe[a] for a in pipe. Also creates JuMP expressions for direction-valued flow, e.g., q_pipe[a] = qp_pipe[a] - qn_pipe[a] for a in pipe. Also creates binary flow direction variables, e.g., y_pipe[a] for a in pipe, where one indicates flow traveling from node_fr (tail of the arc) to node_to (head of the arc). Also creates direction-based head difference variables for pipes and design pipes in the network, e.g., dhp_pipe[a] and dhn_pipe[a] for a in pipe. Then, creates continuous convex combination variables used to construct necessary piecewise-linear relaxations, e.g., lambda_p_pipe[a] and lambda_n_pipe[a] for a in pipe, where each is bounded between zero and one. Finally, creates binary convex combination variables used for piecewise-linear modeling of the relaxation constraints, e.g., x_p_pipe[a] and x_n_pipe[a] for a in pipe.\n\n\n\n\n\n","category":"function"},{"location":"examples.html#WaterModels-Examples","page":"Examples","title":"WaterModels Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The examples directory contains two water network optimization instances that have been developed or modified from two literature instances.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The first is the famous \"two-loop\" water network design instance. (It is sometimes titled after one of its authors as shamir.) This design instance dates back to 1977, first appearing in [1]. The globally optimal design cost is known to be $419,000. Solutions of this instance using various formulation types and assumptions appeared in the Quick Start Guide. As an example, it can be solved using a linear relaxation-based formulation (LRDWaterModel) via the following:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using WaterModels\nimport HiGHS\n\ndata = parse_file(\"examples/data/json/shamir.json\")\nset_flow_partitions_si!(data, 0.5, 1.0e-4)\nresult = solve_des(data, LRDWaterModel, HiGHS.Optimizer)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The second is a modified version of the popular van_zyl optimal water flow instance, which first appeared in [2] and is also named after one of that article's authors. Unlike the design problem, this problem has temporal aspects. It can be constructed and solved (e.g., using the LRDWaterModel formulation) using the following:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using WaterModels\nimport HiGHS\nimport JuMP\n\ndata = parse_file(\"examples/data/epanet/van_zyl.inp\")\ndata_mn = WaterModels.make_multinetwork(data)\nset_flow_partitions_si!(data_mn, 1.0, 1.0e-4)\nhighs = JuMP.optimizer_with_attributes(HiGHS.Optimizer, \"time_limit\" => 60.0)\nresult = solve_mn_owf(data_mn, LRDWaterModel, highs)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The instance is challenging, and only a feasible solution is returned within the time limit for the script above. Also note that results are presented in an automatically-applied per-unit system. To convert the solution to SI units, the following can be executed:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"make_si_units!(result[\"solution\"])","category":"page"},{"location":"examples.html#References","page":"Examples","title":"References","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"[1] Alperovits, E., & Shamir, U. (1977). Design of optimal water distribution systems. Water Resources Research, 13(6), 885-900.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"[2] Van Zyl, J. E., Savic, D. A., & Walters, G. A. (2004). Operational optimization of water distribution systems using a hybrid genetic algorithm. Journal of Water Resources Planning and Management, 130(2), 160-170.","category":"page"},{"location":"objective.html#Objective","page":"Objective","title":"Objective","text":"","category":"section"},{"location":"objective.html","page":"Objective","title":"Objective","text":"objective_wf\nobjective_des\nobjective_owf","category":"page"},{"location":"objective.html#WaterModels.objective_wf","page":"Objective","title":"WaterModels.objective_wf","text":"objective_wf(wm::AbstractWaterModel)\n\nSets the objective for Water Flow (WF) problem specifications. By default, only feasibility must be satisfied, i.e., there is no objective.\n\n\n\n\n\n","category":"function"},{"location":"objective.html#WaterModels.objective_des","page":"Objective","title":"WaterModels.objective_des","text":"objective_des(wm::AbstractWaterModel)\n\nSets and returns the objective function for network design (des) problem specifications. By default, the cost of selecting the discrete pipe resistances over all design pipes and time indices is minimized. That is, the objective is\n\ntextminimize  sum_t in mathcalT\nsum_(i j) in mathcalA^textrmdes_t c_ijt z_ijt\n\nwhere mathcalT is the set of time indices, mathcalA^textrmdes_t is the set of design pipes that are available at time index t, c_ijt is the cost of installing design pipe (i j) at time index t, and z_ijt is a binary variable indicating whether (1) or not (0) the design pipe is selected for construction.\n\n\n\n\n\n","category":"function"},{"location":"objective.html#WaterModels.objective_owf","page":"Objective","title":"WaterModels.objective_owf","text":"objective_owf(wm::AbstractWaterModel)\n\nSets the objective for optimal water flow (owf) problem specifications. By default, minimizes the costs associated with (1) extracting water from each reservoir at some volumetric flow rate and (2) pumping operations, which consume power at predefined electricity rates. That is, the objective is\n\ntextminimize  sum_t in mathcalT^prime Delta t\nleft(leftsum_(i j) in mathcalP_t pi_ijt P_ijtright +\nleftsum_i in mathcalR_t mu_it q_itrightright)\n\nwhere mathcalT^prime = mathcalT setminus T is the set of time indices without the last time index, which is reserved only for computing the final volumes of tanks; Delta t is the time step connecting time t with time t + 1; mathcalP_t is the set of pumps available for operation at time t; pi_ijt is the price of electricity (cost per unit energy) used for pumping at pump (i j) and time t; P_ijt is the power consumption of pump (i j) at time t; mathcalR_t is the set of reservoirs available at time t; mu_it is the cost of extracting (and treating) one volumetric unit of water from reservoir i at time t; and q_it is the volumetric flow rate of water extracted from reservoir i at time t.\n\n\n\n\n\n","category":"function"},{"location":"index.html#WaterModels.jl-Documentation","page":"Home","title":"WaterModels.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = WaterModels","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"WaterModels.jl is a Julia/JuMP package for steady-state potable water distribution network optimization. It is designed to enable the computational evaluation of historical and emerging water network optimization formulations and algorithms using a common platform. The code is specifically engineered to decouple Problem Specifications (e.g., water flow, optimal water flow, network design) from Network Formulations (e.g., mixed-integer linear, mixed-integer nonlinear). This decoupling enables the definition of a wide variety of water network optimization formulations and their comparison across several common problem specifications.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The latest stable release of WaterModels can be installed using the Julia package manager with","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add WaterModels","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For the current development version, install the package using","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add WaterModels#master","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Finally, test that the package works as expected by executing","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] test WaterModels","category":"page"},{"location":"index.html#Usage-at-a-Glance","page":"Home","title":"Usage at a Glance","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"At least one optimization solver is required to run WaterModels. The solver selected typically depends on the type of problem formulation being employed. As an example, to solve a mixed-integer linear programming (MILP) formulation of the feasible water flow (wf) problem, the open-source MILP solver HiGHS can be used. Installation of the JuMP interface to HiGHS can be performed via the Julia package manager, i.e.,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add HiGHS","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Then, as one example, a piecewise-linear, relaxation-based convexification of the physics for the well-known Shamir (two-loop) network, using an error tolerance of one meter to model the envelope of each pipe's Hazen-Williams head loss curve, can be solved to feasibility using","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using WaterModels, HiGHS\n\n# Parse the network data from an EPANET file.\nnetwork = parse_file(\"examples/data/epanet/shamir.inp\")\n\n# Set linearization partitioning points that assume a head loss error tolerance of one\n# meter, with widths between flow points no greater than 1.0e-4 cubic meters per second.\nset_flow_partitions_si!(network, 1.0, 1.0e-4)\n\n# Solve the corresponding relaxation of the water flow problem.\nresult = solve_wf(network, PWLRDWaterModel, HiGHS.Optimizer)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"After solving the problem, results can then be analyzed, e.g.,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"# The termination status of the optimization solver.\nresult[\"termination_status\"]\n\n# Transform solution data to SI units.\nmake_si_units!(result[\"solution\"])\n\n# The flow along pipe 4 in cubic meters per second.\nresult[\"solution\"][\"pipe\"][\"4\"][\"q\"]\n\n# The total hydraulic head at node 2 in meters.\nresult[\"solution\"][\"node\"][\"2\"][\"h\"]\n\n# The pressure head at node 2 in meters.\nresult[\"solution\"][\"node\"][\"2\"][\"p\"]","category":"page"}]
}
